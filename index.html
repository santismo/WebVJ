<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>YouTube Overlay VJ (FX Stack)</title>
  <style>
    :root{
      --bg:#07080c;
      --panel:#0f1118;
      --panel2:#0b0d13;
      --text:#eef1f7;
      --muted:#a9b0bf;
      --border:rgba(255,255,255,.10);
      --accent:#7aa2ff;
      --maxw:1100px;
      --radius:14px;
    }
    html,body{background:var(--bg); color:var(--text); margin:0; font-family:system-ui,-apple-system,sans-serif;}
    .wrap{max-width:var(--maxw); margin:18px auto; padding:0 14px; display:grid; gap:12px;}
    h1{font-size:18px; margin:0;}
    .topbar{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;}
    .btnrow{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    button{
      background:var(--panel);
      color:var(--text);
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      font-size:15px;
    }
    button.primary{
      border-color:rgba(122,162,255,.55);
      box-shadow:0 0 0 2px rgba(122,162,255,.10) inset;
    }
    button.ghost{background:transparent}
    .hint{font-size:12px; color:var(--muted);}

    .stage{
      position:relative;
      width:min(96vw,var(--maxw));
      aspect-ratio:16/9;
      border-radius:var(--radius);
      overflow:hidden;
      background:#000;
      border:1px solid var(--border);
      isolation:isolate;
    }
    .stage:fullscreen{
      width:100vw; height:100vh; aspect-ratio:auto;
      border-radius:0; border:none;
    }

    /* IMPORTANT: YT iframes hate display:none at creation time. */
    .layer{
      position:absolute; inset:0;
      transform-origin:50% 50%;
      pointer-events:none;
      will-change: transform, filter, opacity;
      display:block;
      opacity:1;
    }
    .layer.base{pointer-events:auto;}
    .layer iframe{width:100%; height:100%; border:0; display:block;}
    .hidden{display:none !important;}

    /* Overlays that DO NOT depend on pixel access */
    .overlayFx{position:absolute; inset:0; pointer-events:none; z-index:50; opacity:0;}
    #scanlines{
      background:repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.09) 0px,
        rgba(255,255,255,.09) 1px,
        rgba(0,0,0,0) 3px,
        rgba(0,0,0,0) 7px
      );
      mix-blend-mode:overlay;
    }
    #vignette{
      background:radial-gradient(circle at center, rgba(0,0,0,0) 45%, rgba(0,0,0,.65) 100%);
      mix-blend-mode:multiply;
    }
    #rollbar{
      background:linear-gradient(to bottom, rgba(255,255,255,0) 0%, rgba(255,255,255,.18) 50%, rgba(255,255,255,0) 100%);
      mix-blend-mode:overlay;
      transform:translateY(-120%);
      opacity:0;
    }
    #noiseSvg{
      opacity:0;
      mix-blend-mode:overlay;
      filter:contrast(140%) brightness(90%);
    }

    /* Fake ASCII overlay (not real conversion) */
    #ascii{
      opacity:0;
      mix-blend-mode:screen;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: rgba(255,255,255,.65);
      font-size: 10px;
      line-height: 10px;
      white-space: pre;
      padding: 8px;
      overflow:hidden;
      text-shadow: 0 0 8px rgba(122,162,255,.25);
    }

    .playOverlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      background:linear-gradient(to bottom, rgba(0,0,0,.20), rgba(0,0,0,.65));
      backdrop-filter: blur(2px);
      opacity:0; pointer-events:none;
      transition:opacity .2s ease;
      z-index:80;
    }
    .playOverlay.show{opacity:1; pointer-events:auto;}
    .playOverlay button{
      font-size:16px;
      padding:12px 16px;
      border-radius:999px;
      background:rgba(15,17,24,.75);
      border:1px solid rgba(122,162,255,.6);
    }

    /* iOS pseudo-fullscreen fallback */
    body.pseudo-fs{ overflow:hidden; }
    body.pseudo-fs .wrap{ max-width:none; margin:0; padding:0; }
    body.pseudo-fs .topbar, body.pseudo-fs #controlsPanel{ display:none; }
    body.pseudo-fs .stage{
      position:fixed; inset:0; width:100vw; height:100vh;
      border-radius:0; border:none; aspect-ratio:auto;
      z-index:9999;
    }
    body.pseudo-fs .fsHud{ display:flex; }

    .fsHud{
      position:absolute; top:10px; right:10px; left:10px;
      display:none; justify-content:space-between; gap:10px;
      z-index:90; pointer-events:none;
    }
    .fsHud .hudBtn{
      pointer-events:auto;
      background:rgba(15,17,24,.65);
      border:1px solid rgba(255,255,255,.18);
      border-radius:999px;
      padding:9px 12px;
      font-size:14px;
      backdrop-filter: blur(6px);
    }

    .panel{
      background:var(--panel2);
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
    }
    .panelHead{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px; gap:10px;
      border-bottom:1px solid var(--border);
    }
    .panelBody{padding:12px; display:none;}
    .panel.open .panelBody{display:block;}
    .mini{display:flex; gap:8px; flex-wrap:wrap; align-items:center; color:var(--muted); font-size:12px;}
    .pill{
      border:1px solid var(--border);
      padding:3px 8px;
      border-radius:999px;
      background:rgba(255,255,255,.03);
    }

    .card{
      border:1px solid var(--border);
      border-radius:var(--radius);
      background:rgba(255,255,255,.02);
      overflow:hidden;
      margin-bottom:12px;
    }
    .cardHead{
      padding:10px 12px;
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
      border-bottom:1px solid var(--border);
    }
    .cardTitle{font-weight:700; font-size:14px;}
    .row{
      display:grid; gap:10px;
      grid-template-columns:1fr 1fr;
      padding:12px;
    }
    @media (max-width:820px){ .row{grid-template-columns:1fr;} }
    label{display:grid; gap:6px; font-size:13px; color:var(--muted);}
    input[type="text"], select{
      width:100%;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.30);
      color:var(--text);
      font-size:15px;
      outline:none;
    }
    input[type="range"]{width:100%;}
    .toggle{display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px; user-select:none;}
    .toggle input{transform:scale(1.05)}
    .btnGroup{display:flex; gap:10px; flex-wrap:wrap; padding:12px;}
    .btnGroup button{padding:9px 11px; font-size:14px;}
    .small{font-size:12px; color:var(--muted);}
    .divider{height:1px; background:var(--border); margin:0 12px;}

    /* Preset button highlight */
    .presetBtn.active{
      border-color: rgba(122,162,255,.75);
      box-shadow: 0 0 0 2px rgba(122,162,255,.14) inset;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>YouTube Overlay VJ</h1>
        <div class="hint">All FX OFF by default. Use toggles or presets (highlighted when active).</div>
      </div>
      <div class="btnrow">
        <button id="reloadBtn" class="ghost">Reload</button>
        <button id="playBtn" class="primary">Play</button>
        <button id="pauseBtn">Pause</button>
        <button id="fsBtn">Full screen</button>
        <button id="controlsBtn">Expand controls</button>
      </div>
    </div>

    <div class="stage" id="stage">
      <div class="fsHud" id="fsHud">
        <button class="hudBtn" id="hudPlay">Play</button>
        <button class="hudBtn" id="hudExit">Exit</button>
      </div>

      <!-- 0=base, 1=overlay, 2..4=echo copies used by some FX -->
      <div id="layer0" class="layer base"></div>
      <div id="layer1" class="layer"></div>
      <div id="layer2" class="layer hidden"></div>
      <div id="layer3" class="layer hidden"></div>
      <div id="layer4" class="layer hidden"></div>

      <!-- Overlays -->
      <div id="scanlines" class="overlayFx"></div>
      <div id="vignette" class="overlayFx"></div>
      <div id="rollbar" class="overlayFx"></div>

      <!-- SVG noise overlay -->
      <svg id="noiseSvg" class="overlayFx" viewBox="0 0 100 100" preserveAspectRatio="none">
        <filter id="noiseFilter">
          <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="3" stitchTiles="stitch" />
          <feColorMatrix type="saturate" values="0" />
        </filter>
        <rect x="0" y="0" width="100" height="100" filter="url(#noiseFilter)" opacity="0.35"></rect>
      </svg>

      <div id="ascii" class="overlayFx"></div>

      <div class="playOverlay" id="playOverlay">
        <button id="tapPlayBtn">Tap to Play</button>
      </div>
    </div>

    <div class="panel" id="controlsPanel">
      <div class="panelHead">
        <div class="mini">
          <span class="pill">2 main layers</span>
          <span class="pill">echo layers on-demand</span>
          <span class="pill">iframe-safe overlays</span>
        </div>
        <div class="btnrow">
          <button id="hidePanelBtn" class="ghost">Hide</button>
        </div>
      </div>

      <div class="panelBody">
        <div class="card">
          <div class="cardHead"><div class="cardTitle">Sources</div></div>
          <div class="row">
            <label>Base URL (Layer 1)
              <input id="url0" type="text">
            </label>
            <label>Overlay URL (Layer 2)
              <input id="url1" type="text">
            </label>
          </div>
          <div class="row">
            <label>Base opacity
              <input id="op0" type="range" min="0" max="1" step="0.01" value="1">
            </label>
            <label>Overlay opacity
              <input id="op1" type="range" min="0" max="1" step="0.01" value="0.85">
            </label>
          </div>
          <div class="row">
            <label>Overlay blend mode
              <select id="blend1"></select>
            </label>
            <label>Overlay invert (default max)
              <input id="inv1" type="range" min="0" max="1" step="0.01" value="1">
            </label>
          </div>
          <div class="row">
            <label>Overlay contrast
              <input id="ct1" type="range" min="0.5" max="3.0" step="0.01" value="1.6">
            </label>
            <label>Overlay saturation
              <input id="sat1" type="range" min="0" max="3.0" step="0.01" value="1.2">
            </label>
          </div>
          <div class="btnGroup">
            <button id="muteBaseBtn">Unmute base</button>
            <button id="muteOvBtn">Unmute overlay</button>
          </div>
          <div class="small" style="padding:0 12px 12px;">
            If it’s blank on iOS, hit <b>Play</b> once (autoplay is often blocked).
          </div>
        </div>

        <div class="card">
          <div class="cardHead"><div class="cardTitle">FX toggles (all OFF by default)</div></div>

          <div class="row">
            <label class="toggle"><input id="fxTrail" type="checkbox"> Trail / Echo (uses echo layers)</label>
            <label>Trail amount
              <input id="trailAmt" type="range" min="0" max="1" step="0.01" value="0.75">
            </label>
          </div>

          <div class="row">
            <label class="toggle"><input id="fxRGB" type="checkbox"> RGB Shift (uses echo layers)</label>
            <label>RGB amount
              <input id="rgbAmt" type="range" min="0" max="1" step="0.01" value="0.75">
            </label>
          </div>

          <div class="row">
            <label class="toggle"><input id="fxGlitch" type="checkbox"> Glitch (jitter/flash)</label>
            <label>Glitch amount
              <input id="glitchAmt" type="range" min="0" max="1" step="0.01" value="0.7">
            </label>
          </div>

          <div class="row">
            <label class="toggle"><input id="fxFeedback" type="checkbox"> Feedback Tunnel (illusion)</label>
            <label>Feedback intensity
              <input id="fbAmt" type="range" min="0" max="1" step="0.01" value="0.8">
            </label>
          </div>

          <div class="row">
            <label class="toggle"><input id="fxMirror" type="checkbox"> Mirror / Quad (visible “kaleido-ish”)</label>
            <label>Mirror mode
              <select id="mirMode">
                <option value="quad">quad</option>
                <option value="mx">mirror X</option>
                <option value="my">mirror Y</option>
                <option value="mxy">mirror X+Y</option>
              </select>
            </label>
          </div>

          <div class="row">
            <label class="toggle"><input id="fxRaster" type="checkbox"> CRT Raster (scanlines + rollbar + vignette)</label>
            <label>Raster intensity
              <input id="rastAmt" type="range" min="0" max="1" step="0.01" value="0.7">
            </label>
          </div>

          <div class="row">
            <label class="toggle"><input id="fxNoise" type="checkbox"> Noise overlay (SVG turbulence)</label>
            <label>Noise intensity
              <input id="noiseAmt" type="range" min="0" max="1" step="0.01" value="0.6">
            </label>
          </div>

          <div class="row">
            <label class="toggle"><input id="fxAscii" type="checkbox"> Fake ASCII overlay (animated text)</label>
            <label>ASCII intensity
              <input id="asciiAmt" type="range" min="0" max="1" step="0.01" value="0.55">
            </label>
          </div>

          <div class="divider"></div>

          <div class="btnGroup">
            <button id="allOff" class="ghost">All FX Off</button>
          </div>
          <div class="small" style="padding:0 12px 12px;">
            Note: true pixel shaders / real ASCII conversion aren’t possible with YouTube iframes (cross-origin).
          </div>
        </div>

        <div class="card">
          <div class="cardHead"><div class="cardTitle">Presets (optional)</div></div>
          <div class="btnGroup">
            <button class="presetBtn ghost" id="pNone">None</button>
            <button class="presetBtn" id="pTrip">Trip Default</button>
            <button class="presetBtn" id="pNeon">Neon CRT</button>
            <button class="presetBtn" id="pGlitchy">Glitch Bloom</button>
            <button class="presetBtn" id="pKaleido">Kaleido Quad</button>
            <button class="presetBtn" id="pFeedback">Feedback Spiral</button>
          </div>
          <div class="small" style="padding:0 12px 12px;">
            Presets just toggle FX + set amounts; you can still tweak anything after.
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------- Defaults ----------
    const DEFAULT0 = "https://m.youtube.com/watch?v=3pxrECZYEAA&pp=ygUOdmlzdWFscyB0cmlwcHk%3D";
    const DEFAULT1 = "https://m.youtube.com/watch?v=dS-MaUk6YBI";

    const blendModes = [
      "normal","multiply","screen","overlay","darken","lighten","color-dodge","color-burn",
      "hard-light","soft-light","difference","exclusion","hue","saturation","color","luminosity"
    ];

    // YouTube players: 0..4
    const players = new Array(5).fill(null);
    const loadedIds = new Array(5).fill(null);

    let mutedBase = true;
    let mutedOv = true;

    // layer config (CSS only)
    const cfg = Array.from({length:5}, () => ({
      enabled: false,
      opacity: 1,
      blend: "normal",
      inv: 0, ct: 1, br: 1, sat: 1, hue: 0, blur: 0,
      x: 0, y: 0, scale: 1, rot: 0,
      flipX: false, flipY: false,
      clip: "none"
    }));

    // preset UI
    const presetButtons = [];

    // ---------- Utilities ----------
    function $(id){ return document.getElementById(id); }

    function extractVideoId(url) {
      if (!url) return null;
      const raw = url.trim();
      if (/^[a-zA-Z0-9_-]{11}$/.test(raw)) return raw;
      try {
        const u = new URL(raw);
        if (u.hostname.includes("youtu.be")) return u.pathname.replace("/", "") || null;
        const v = u.searchParams.get("v");
        if (v) return v;
        const parts = u.pathname.split("/").filter(Boolean);
        const embedIdx = parts.indexOf("embed");
        if (embedIdx >= 0 && parts[embedIdx + 1]) return parts[embedIdx + 1];
      } catch (e) {}
      return null;
    }

    function setLayerVisibleForYT(i){
      // must not be display:none at mount time
      const layer = $(`layer${i}`);
      layer.classList.remove("hidden");
      layer.style.display = "block";
      layer.style.opacity = "1";
    }

    function destroyPlayer(i){
      try { players[i] && players[i].destroy && players[i].destroy(); } catch(e){}
      players[i] = null;
      loadedIds[i] = null;
      $(`layer${i}`).innerHTML = "";
    }

    function mountPlayer(i, videoId){
      setLayerVisibleForYT(i);
      const layer = $(`layer${i}`);
      layer.innerHTML = `<div id="player${i}"></div>`;
      players[i] = new YT.Player(`player${i}`, {
        videoId,
        playerVars: { playsinline: 1, rel: 0 },
        events: {
          onReady: (e) => { try { e.target.mute(); } catch(err){} }
        }
      });
      loadedIds[i] = videoId;
    }

    function applyLayerCSS(i){
      const el = $(`layer${i}`);
      const c = cfg[i];

      // layers 0 and 1 always visible
      if (i <= 1) el.classList.remove("hidden");
      else el.classList.toggle("hidden", !c.enabled);

      el.style.opacity = c.opacity;
      el.style.mixBlendMode = c.blend;

      const sx = c.flipX ? -1 : 1;
      const sy = c.flipY ? -1 : 1;

      el.style.transform =
        `translate(${c.x}%, ${c.y}%) scale(${c.scale * sx}, ${c.scale * sy}) rotate(${c.rot}deg)`;

      el.style.filter =
        `invert(${c.inv}) contrast(${c.ct}) brightness(${c.br}) saturate(${c.sat}) hue-rotate(${c.hue}deg) blur(${c.blur}px)`;

      el.style.clipPath = c.clip === "none" ? "none" : c.clip;
    }

    function applyAllCSS(){
      for (let i=0;i<5;i++) applyLayerCSS(i);
      for (let i=0;i<5;i++) $(`layer${i}`).classList.toggle("base", i===0);
    }

    function setMainFromUI(){
      // base
      cfg[0].enabled = true;
      cfg[0].opacity = parseFloat($("op0").value);
      cfg[0].blend = "normal";
      cfg[0].inv=0; cfg[0].ct=1; cfg[0].br=1; cfg[0].sat=1; cfg[0].hue=0; cfg[0].blur=0;
      cfg[0].x=0; cfg[0].y=0; cfg[0].scale=1; cfg[0].rot=0;
      cfg[0].flipX=false; cfg[0].flipY=false; cfg[0].clip="none";

      // overlay
      cfg[1].enabled = true;
      cfg[1].opacity = parseFloat($("op1").value);
      cfg[1].blend = $("blend1").value;
      cfg[1].inv = parseFloat($("inv1").value);
      cfg[1].ct  = parseFloat($("ct1").value);
      cfg[1].br  = 1.0;
      cfg[1].sat = parseFloat($("sat1").value);
      cfg[1].hue = 0;
      cfg[1].blur = 0;
      cfg[1].x=0; cfg[1].y=0; cfg[1].scale=1; cfg[1].rot=0;
      cfg[1].flipX=false; cfg[1].flipY=false; cfg[1].clip="none";
    }

    function anyEchoFXEnabled(){
      return $("fxTrail").checked || $("fxRGB").checked || $("fxFeedback").checked || $("fxMirror").checked;
    }

    function ensureEchoPlayersLoaded(){
      const ovId = loadedIds[1];
      if (!ovId) return;

      for (let i=2;i<=4;i++){
        if (!cfg[i].enabled) continue;
        if (loadedIds[i] === ovId && players[i]) continue;
        destroyPlayer(i);
        mountPlayer(i, ovId);
      }
    }

    function bestEffortSyncEchoTimes(){
      try{
        const t = players[1]?.getCurrentTime?.();
        if (typeof t !== "number") return;
        // tiny offsets can look like delay
        const offsets = [0.10, 0.18, 0.28];
        for (let i=2;i<=4;i++){
          if (!players[i]?.seekTo) continue;
          const dt = offsets[i-2] || 0.1;
          try { players[i].seekTo(Math.max(0, t - dt), true); } catch(e){}
        }
      } catch(e){}
    }

    // ---------- Playback ----------
    async function tryAutoplayMuted(){
      let attempted = false;
      for (let i=0;i<5;i++){
        if (i>=2 && !cfg[i].enabled) continue;
        try{
          if (players[i]){
            players[i].mute();
            players[i].playVideo();
            attempted = true;
          }
        } catch(e){}
      }
      return attempted;
    }

    function playAll(){
      for (let i=0;i<5;i++){
        if (i>=2 && !cfg[i].enabled) continue;
        try { players[i] && players[i].mute(); } catch(e){}
        try { players[i] && players[i].playVideo(); } catch(e){}
      }
      $("playOverlay").classList.remove("show");
    }

    function pauseAll(){
      for (let i=0;i<5;i++){
        try { players[i] && players[i].pauseVideo(); } catch(e){}
      }
    }

    // ---------- Fullscreen ----------
    function isRealFullscreenSupported(){
      const stage = $("stage");
      return !!(stage.requestFullscreen && document.fullscreenEnabled);
    }
    async function toggleFullscreen(){
      const stage = $("stage");
      if (document.body.classList.contains("pseudo-fs")){
        document.body.classList.remove("pseudo-fs");
        return;
      }
      if (isRealFullscreenSupported()){
        try{
          if (document.fullscreenElement) await document.exitFullscreen();
          else await stage.requestFullscreen();
          return;
        } catch(e){}
      }
      document.body.classList.add("pseudo-fs");
    }

    // ---------- FX Engine ----------
    function setOverlays(){
      // Raster
      const rastOn = $("fxRaster").checked;
      const rastAmt = parseFloat($("rastAmt").value);
      $("scanlines").style.opacity = rastOn ? (0.55 * rastAmt).toFixed(3) : "0";
      $("vignette").style.opacity  = rastOn ? (0.75 * rastAmt).toFixed(3) : "0";

      // Rolling bar: visible only if raster on
      $("rollbar").style.opacity = rastOn ? (0.65 * rastAmt).toFixed(3) : "0";

      // Noise
      const noiseOn = $("fxNoise").checked;
      const noiseAmt = parseFloat($("noiseAmt").value);
      $("noiseSvg").style.opacity = noiseOn ? (0.9 * noiseAmt).toFixed(3) : "0";

      // Fake ASCII
      const asciiOn = $("fxAscii").checked;
      const asciiAmt = parseFloat($("asciiAmt").value);
      $("ascii").style.opacity = asciiOn ? (0.9 * asciiAmt).toFixed(3) : "0";
    }

    function stepNoise(time, freq){
      const k = Math.max(0.001, 1 / Math.max(0.01, freq));
      const bucket = Math.floor(time / k);
      const x = Math.sin(bucket * 999.123) * 10000;
      return (x - Math.floor(x)) * 2 - 1;
    }

    function applyEchoFx(time){
      // default echo layers off unless needed
      for (let i=2;i<=4;i++){
        cfg[i].enabled = false;
        cfg[i].clip = "none";
      }

      if (!anyEchoFXEnabled()) return;

      // turn on echoes
      for (let i=2;i<=4;i++) cfg[i].enabled = true;

      // build a strong baseline
      for (let i=2;i<=4;i++){
        cfg[i].opacity = 0.0;
        cfg[i].blend = "screen";
        cfg[i].inv = 0;
        cfg[i].ct = 1.25;
        cfg[i].br = 1.0;
        cfg[i].sat = 1.5;
        cfg[i].hue = 0;
        cfg[i].blur = 0.8;
        cfg[i].x = 0; cfg[i].y = 0;
        cfg[i].scale = 1.0;
        cfg[i].rot = 0;
        cfg[i].flipX = false;
        cfg[i].flipY = false;
      }

      // Trail / Echo
      if ($("fxTrail").checked){
        const A = parseFloat($("trailAmt").value);
        // MUCH more prominent
        cfg[2].opacity = 0.35 * A;
        cfg[3].opacity = 0.25 * A;
        cfg[4].opacity = 0.18 * A;
        cfg[2].blur = 2.4 * A;
        cfg[3].blur = 4.2 * A;
        cfg[4].blur = 6.2 * A;
        cfg[4].blend = "difference";
        cfg[2].x = Math.sin(time*1.1) * 3.0 * A;  cfg[2].y = Math.cos(time*1.0) * 2.2 * A;
        cfg[3].x = Math.sin(time*0.8+1.6) * -3.6 * A; cfg[3].y = Math.cos(time*0.9+0.4) * 2.7 * A;
        cfg[4].x = Math.sin(time*0.6+2.4) * 2.2 * A;  cfg[4].y = Math.cos(time*0.7+1.2) * -3.2 * A;
      }

      // RGB Shift (makes echoes more “channel split”)
      if ($("fxRGB").checked){
        const A = parseFloat($("rgbAmt").value);
        // push hue/offset hard so it’s obvious
        cfg[2].blend = "screen"; cfg[2].hue =  35; cfg[2].sat = 2.2; cfg[2].ct = 1.35; cfg[2].opacity = Math.max(cfg[2].opacity, 0.28*A);
        cfg[3].blend = "screen"; cfg[3].hue = -35; cfg[3].sat = 2.2; cfg[3].ct = 1.35; cfg[3].opacity = Math.max(cfg[3].opacity, 0.28*A);
        cfg[4].blend = "screen"; cfg[4].hue =  0;  cfg[4].sat = 2.6; cfg[4].ct = 1.18; cfg[4].opacity = Math.max(cfg[4].opacity, 0.22*A);

        const wob = Math.sin(time*1.7) * 1.2 * A;
        cfg[2].x += ( 3.4*A + wob); cfg[3].x += (-3.4*A - wob); cfg[4].y += (2.2*A + Math.cos(time*1.3)*0.8*A);
        cfg[2].blur = Math.max(cfg[2].blur, 0.7*A);
        cfg[3].blur = Math.max(cfg[3].blur, 0.7*A);
      }

      // Feedback Tunnel illusion
      if ($("fxFeedback").checked){
        const A = parseFloat($("fbAmt").value);
        // scale up, rotate, drift slightly, and blend
        cfg[2].opacity = Math.max(cfg[2].opacity, 0.22*A);
        cfg[3].opacity = Math.max(cfg[3].opacity, 0.18*A);
        cfg[4].opacity = Math.max(cfg[4].opacity, 0.14*A);

        cfg[2].scale = 1.02 + 0.06*A;
        cfg[3].scale = 1.05 + 0.09*A;
        cfg[4].scale = 1.08 + 0.12*A;

        cfg[2].rot += time*8*A;
        cfg[3].rot += time*12*A;
        cfg[4].rot += time*16*A;

        cfg[2].x += Math.sin(time*1.1)*2.5*A; cfg[2].y += Math.cos(time*1.0)*1.8*A;
        cfg[3].x += Math.sin(time*0.9+2)*-2.8*A; cfg[3].y += Math.cos(time*1.2+1)*2.2*A;
        cfg[4].x += Math.sin(time*0.7+3)*1.9*A; cfg[4].y += Math.cos(time*0.8+2)*-2.4*A;

        cfg[2].blur = Math.max(cfg[2].blur, 1.2*A);
        cfg[3].blur = Math.max(cfg[3].blur, 2.2*A);
        cfg[4].blur = Math.max(cfg[4].blur, 3.2*A);
        cfg[4].blend = "difference";
      }

      // Mirror / “Kaleido-ish” (quad uses clip + flips so it’s VERY obvious)
      if ($("fxMirror").checked){
        const mode = $("mirMode").value;

        // Make mirror dominate:
        cfg[2].opacity = Math.max(cfg[2].opacity, 0.40);
        cfg[3].opacity = Math.max(cfg[3].opacity, 0.35);
        cfg[4].opacity = Math.max(cfg[4].opacity, 0.28);
        cfg[2].blend = "screen";
        cfg[3].blend = "screen";
        cfg[4].blend = "difference";
        cfg[2].blur = Math.max(cfg[2].blur, 0.7);
        cfg[3].blur = Math.max(cfg[3].blur, 0.9);
        cfg[4].blur = Math.max(cfg[4].blur, 1.2);

        if (mode === "mx"){
          cfg[2].flipX = true;
        } else if (mode === "my"){
          cfg[2].flipY = true;
        } else if (mode === "mxy"){
          cfg[2].flipX = true; cfg[2].flipY = true;
        } else {
          // QUAD:
          // layer2 top-left, layer3 top-right, layer4 bottom-left-ish (and base+overlay already fill)
          // Use clip-path to create quadrants; flips to create mirror feel.
          cfg[2].clip = "inset(0 50% 50% 0)";
          cfg[3].clip = "inset(0 0 50% 50%)";
          cfg[4].clip = "inset(50% 50% 0 0)";

          cfg[2].flipX = true;
          cfg[3].flipY = true;
          cfg[4].flipX = true; cfg[4].flipY = true;

          // slight rotation drift makes it kaleido-ish
          cfg[2].rot += Math.sin(time*0.7)*6;
          cfg[3].rot += Math.cos(time*0.9)*6;
          cfg[4].rot += Math.sin(time*1.1)*6;
        }
      }

      // Echo layers loaded if needed
      ensureEchoPlayersLoaded();
    }

    function applyGlitch(time){
      if (!$("fxGlitch").checked) return;

      const A = parseFloat($("glitchAmt").value);
      const spd = 18 + 28*A;
      const n1 = stepNoise(time, spd) * A;
      const n2 = stepNoise(time + 12.34, spd) * A;

      // jitter the overlay (layer1) slightly; keep base stable
      cfg[1].x = n1 * 1.6;
      cfg[1].y = n2 * 1.0;

      // occasional “flash” pulse
      const pop = Math.abs(stepNoise(time, spd*0.25)) > (0.83 - 0.25*A) ? 1 : 0;
      if (pop){
        cfg[1].ct = Math.min(3, cfg[1].ct + 0.8*A);
        cfg[1].opacity = Math.min(1, parseFloat($("op1").value) + 0.25*A);
      }
    }

    // ASCII rain
    const asciiChars = " .,:;i1tfLCG08@#";
    function renderAscii(time){
      if (!$("fxAscii").checked) return;
      const cols = 70;
      const rows = 40;
      let out = "";
      for (let r=0;r<rows;r++){
        for (let c=0;c<cols;c++){
          const v = stepNoise(time + r*0.03 + c*0.01, 18);
          const idx = Math.floor(((v+1)/2) * (asciiChars.length-1));
          out += asciiChars[Math.max(0, Math.min(asciiChars.length-1, idx))];
        }
        out += "\n";
      }
      $("ascii").textContent = out;
    }

    // rollbar animation
    function animateRollbar(time){
      if (!$("fxRaster").checked) {
        $("rollbar").style.transform = "translateY(-120%)";
        return;
      }
      const A = parseFloat($("rastAmt").value);
      const y = ((time * (0.20 + 0.70*A)) % 2.2) - 1.1; // -1.1..1.1
      $("rollbar").style.transform = `translateY(${y*120}%)`;
    }

    // ---------- FX / Presets ----------
    function setPresetActive(btnId){
      presetButtons.forEach(b => b.classList.remove("active"));
      const b = $(btnId);
      if (b) b.classList.add("active");
    }

    function allFxOff(){
      ["fxTrail","fxRGB","fxGlitch","fxFeedback","fxMirror","fxRaster","fxNoise","fxAscii"].forEach(id => $(id).checked = false);
      // also disable echoes
      for (let i=2;i<=4;i++){ cfg[i].enabled=false; destroyPlayer(i); }
      setPresetActive("pNone");
    }

    function applyPreset(name){
      allFxOff();

      if (name === "none"){
        setPresetActive("pNone");
        return;
      }

      if (name === "trip"){
        $("fxTrail").checked = true; $("trailAmt").value = "0.85";
        $("fxRGB").checked = true; $("rgbAmt").value = "0.80";
        $("fxRaster").checked = true; $("rastAmt").value = "0.65";
        $("fxNoise").checked = true; $("noiseAmt").value = "0.50";
        setPresetActive("pTrip");
      }

      if (name === "neon"){
        $("fxRGB").checked = true; $("rgbAmt").value = "0.95";
        $("fxRaster").checked = true; $("rastAmt").value = "0.85";
        $("fxNoise").checked = true; $("noiseAmt").value = "0.60";
        setPresetActive("pNeon");
      }

      if (name === "glitchy"){
        $("fxGlitch").checked = true; $("glitchAmt").value = "0.85";
        $("fxTrail").checked = true; $("trailAmt").value = "0.55";
        $("fxNoise").checked = true; $("noiseAmt").value = "0.70";
        setPresetActive("pGlitchy");
      }

      if (name === "kaleido"){
        $("fxMirror").checked = true; $("mirMode").value = "quad";
        $("fxRGB").checked = true; $("rgbAmt").value = "0.60";
        $("fxFeedback").checked = true; $("fbAmt").value = "0.45";
        setPresetActive("pKaleido");
      }

      if (name === "feedback"){
        $("fxFeedback").checked = true; $("fbAmt").value = "0.95";
        $("fxTrail").checked = true; $("trailAmt").value = "0.55";
        $("fxRaster").checked = true; $("rastAmt").value = "0.75";
        setPresetActive("pFeedback");
      }
    }

    // ---------- Load / init ----------
    function loadAll(){
      const id0 = extractVideoId($("url0").value);
      const id1 = extractVideoId($("url1").value);
      if (!id0 || !id1){
        alert("Please provide valid YouTube URLs (or 11-char IDs).");
        return;
      }

      // destroy all players to reset cleanly
      for (let i=0;i<5;i++) destroyPlayer(i);

      // mount main players
      mountPlayer(0, id0);
      mountPlayer(1, id1);

      // reset base/overlay display
      setMainFromUI();
      applyAllCSS();

      // hide post layers until FX toggled
      for (let i=2;i<=4;i++){ cfg[i].enabled = false; applyLayerCSS(i); }

      // attempt autoplay (muted). If blocked, show tap.
      setTimeout(async () => {
        const attempted = await tryAutoplayMuted();
        $("playOverlay").classList.toggle("show", !attempted);
      }, 650);
    }

    // ---------- Animation loop ----------
    function raf(t){
      const time = t / 1000;

      // Main
      setMainFromUI();

      // overlays
      setOverlays();
      animateRollbar(time);

      // echo-based FX + glitch
      applyEchoFx(time);
      applyGlitch(time);

      // fake ascii
      renderAscii(time);

      applyAllCSS();

      // keep echoes roughly aligned sometimes
      if (anyEchoFXEnabled() && Math.random() < 0.02) bestEffortSyncEchoTimes();

      requestAnimationFrame(raf);
    }

    // ---------- UI wiring ----------
    function wireUI(){
      // panel
      const controlsPanel = $("controlsPanel");
      $("controlsBtn").addEventListener("click", () => {
        controlsPanel.classList.toggle("open");
        $("controlsBtn").textContent = controlsPanel.classList.contains("open") ? "Collapse controls" : "Expand controls";
      });
      $("hidePanelBtn").addEventListener("click", () => {
        controlsPanel.classList.remove("open");
        $("controlsBtn").textContent = "Expand controls";
      });

      // buttons
      $("reloadBtn").addEventListener("click", loadAll);
      $("playBtn").addEventListener("click", playAll);
      $("pauseBtn").addEventListener("click", pauseAll);
      $("tapPlayBtn").addEventListener("click", playAll);
      $("fsBtn").addEventListener("click", toggleFullscreen);
      $("hudPlay").addEventListener("click", playAll);
      $("hudExit").addEventListener("click", toggleFullscreen);

      // mute
      $("muteBaseBtn").addEventListener("click", () => {
        mutedBase = !mutedBase;
        try { mutedBase ? players[0].mute() : players[0].unMute(); } catch(e){}
        $("muteBaseBtn").textContent = mutedBase ? "Unmute base" : "Mute base";
      });
      $("muteOvBtn").addEventListener("click", () => {
        mutedOv = !mutedOv;
        try { mutedOv ? players[1].mute() : players[1].unMute(); } catch(e){}
        $("muteOvBtn").textContent = mutedOv ? "Unmute overlay" : "Mute overlay";
      });

      // all off
      $("allOff").addEventListener("click", allFxOff);

      // preset buttons
      presetButtons.push($("pNone"), $("pTrip"), $("pNeon"), $("pGlitchy"), $("pKaleido"), $("pFeedback"));
      $("pNone").addEventListener("click", () => applyPreset("none"));
      $("pTrip").addEventListener("click", () => applyPreset("trip"));
      $("pNeon").addEventListener("click", () => applyPreset("neon"));
      $("pGlitchy").addEventListener("click", () => applyPreset("glitchy"));
      $("pKaleido").addEventListener("click", () => applyPreset("kaleido"));
      $("pFeedback").addEventListener("click", () => applyPreset("feedback"));
    }

    // ---------- YT API load (fixes your “needs reload” issue) ----------
    function loadYouTubeAPI(){
      return new Promise((resolve) => {
        if (window.YT && window.YT.Player) return resolve();
        const tag = document.createElement("script");
        tag.src = "https://www.youtube.com/iframe_api";
        document.head.appendChild(tag);
        window.onYouTubeIframeAPIReady = () => resolve();
      });
    }

    // ---------- Boot ----------
    async function boot(){
      // UI defaults
      $("url0").value = DEFAULT0;
      $("url1").value = DEFAULT1;

      $("blend1").innerHTML = blendModes.map(m => `<option value="${m}">${m}</option>`).join("");
      $("blend1").value = "difference";
      $("inv1").value = "1";

      // All FX off by default
      allFxOff();

      wireUI();

      // load YT API after DOM is ready, then load players
      await loadYouTubeAPI();
      loadAll();

      // start loop
      requestAnimationFrame(raf);
    }

    document.addEventListener("DOMContentLoaded", boot);
  </script>
</body>
</html>
