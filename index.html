<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>VJ Mixer (YouTube Links) + FX Capture Mode</title>
  <style>
    :root{
      --bg:#07080c;
      --panel:#0f1118;
      --panel2:#0b0d13;
      --text:#e9edf6;
      --muted:#9aa3b5;
      --border:rgba(255,255,255,.12);
      --accent:#7aa2ff;
      --accent2:#ff7bd3;
      --radius:16px;
      --maxw:1200px;
    }
    html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
    .wrap{max-width:var(--maxw);margin:16px auto;padding:0 14px;display:grid;gap:12px;}
    .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .title{display:grid;gap:4px}
    h1{margin:0;font-size:18px;letter-spacing:.2px}
    .sub{font-size:12px;color:var(--muted);line-height:1.25}
    .actions{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{
      background:rgba(255,255,255,.04);
      border:1px solid var(--border);
      color:var(--text);
      border-radius:999px;
      padding:10px 14px;
      font-size:14px;
      cursor:pointer;
    }
    button.primary{
      border-color:rgba(122,162,255,.55);
      box-shadow:0 0 0 2px rgba(122,162,255,.10) inset;
    }
    button.danger{border-color:rgba(255,130,130,.5)}
    button:active{transform:translateY(1px)}
    .seg{
      display:flex; gap:6px; padding:6px; border:1px solid var(--border);
      background:rgba(255,255,255,.03); border-radius:999px;
    }
    .seg button{
      border-radius:999px; padding:8px 12px; border:1px solid transparent;
      background:transparent;
    }
    .seg button.active{
      background:rgba(122,162,255,.18);
      border-color:rgba(122,162,255,.35);
    }

    .stage{
      position:relative;
      width:100%;
      aspect-ratio:16/9;
      border-radius:var(--radius);
      overflow:hidden;
      border:1px solid var(--border);
      background:#000;
      isolation:isolate;
    }
    .stage:fullscreen{width:100vw;height:100vh;aspect-ratio:auto;border-radius:0;border:none;}
    .fsHud{
      position:absolute; top:10px; left:10px; right:10px;
      display:none; justify-content:space-between; gap:10px;
      z-index:99; pointer-events:none;
    }
    .fsHud button{pointer-events:auto;background:rgba(10,12,18,.55);backdrop-filter:blur(8px)}
    body.pseudo-fs{overflow:hidden;}
    body.pseudo-fs .wrap{max-width:none;margin:0;padding:0;}
    body.pseudo-fs .topbar, body.pseudo-fs #controls{display:none;}
    body.pseudo-fs .stage{
      position:fixed; inset:0; width:100vw; height:100vh; aspect-ratio:auto;
      border-radius:0;border:none; z-index:9999;
    }
    body.pseudo-fs .fsHud{display:flex;}

    /* Link mixer layers */
    .layersRoot{position:absolute;inset:0; z-index:10;}
    .layer{position:absolute;inset:0;pointer-events:none;will-change:opacity,filter,transform;mix-blend-mode:normal;opacity:1;}
    .layer iframe{width:100%;height:100%;border:0;display:block;}

    /* FX output canvas */
    canvas#fxOut{
      position:absolute; inset:0; width:100%; height:100%;
      display:none; z-index:30;
    }

    /* Tap-to-start overlay (for autoplay restrictions) */
    .gate{
      position:absolute; inset:0; display:none;
      align-items:center; justify-content:center;
      background:linear-gradient(to bottom, rgba(0,0,0,.10), rgba(0,0,0,.75));
      z-index:80;
    }
    .gate.show{display:flex;}
    .gate button{background:rgba(10,12,18,.65);backdrop-filter:blur(8px);}

    /* Controls */
    .controls{
      background:rgba(255,255,255,.03);
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
    }
    .controlsHead{
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
      padding:12px 12px;
      border-bottom:1px solid var(--border);
    }
    .controlsHead .left{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .badge{
      font-size:12px;color:var(--muted);
      border:1px solid var(--border);
      padding:4px 10px;border-radius:999px;background:rgba(255,255,255,.02);
    }
    .controlsBody{display:none;padding:12px;gap:12px}
    .controls.open .controlsBody{display:grid;}
    .grid{display:grid;grid-template-columns: 1fr 1fr; gap:12px;}
    @media (max-width: 980px){.grid{grid-template-columns: 1fr;}}

    .card{
      border:1px solid var(--border);
      border-radius:var(--radius);
      background:rgba(0,0,0,.22);
      overflow:hidden;
    }
    .cardHead{
      padding:10px 12px; border-bottom:1px solid var(--border);
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
    }
    .cardTitle{font-weight:700;font-size:13px;color:var(--text); letter-spacing:.2px}
    .cardBody{padding:12px;display:grid;gap:10px}
    label{display:grid;gap:6px;font-size:12px;color:var(--muted);}
    input[type="text"], select, input[type="number"]{
      width:100%; padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.30);
      color:var(--text);
      font-size:14px;
      outline:none;
    }
    input[type="range"]{width:100%;}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media (max-width: 740px){.row{grid-template-columns:1fr;}}
    .toggle{display:flex;gap:8px;align-items:center;color:var(--muted);font-size:12px;user-select:none}
    .toggle input{transform:scale(1.05)}
    .small{font-size:12px;color:var(--muted);line-height:1.25}

    .pillrow{display:flex;gap:8px;flex-wrap:wrap}
    .pill{
      font-size:12px;color:var(--muted);
      border:1px solid var(--border);
      padding:4px 10px;border-radius:999px;background:rgba(255,255,255,.02);
    }

    /* Mode sections */
    .modeBlock{display:none;}
    .modeBlock.active{display:block;}

    /* Layer list */
    .layerList{display:grid;gap:10px}
    .layerItem{border:1px solid var(--border);border-radius:14px;background:rgba(255,255,255,.02);overflow:hidden}
    .layerItemHead{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;padding:10px 12px;border-bottom:1px solid var(--border);}
    .layerItemHead .name{font-weight:700;font-size:13px}
    .layerItemBody{padding:12px;display:grid;gap:10px}
    .miniBtns{display:flex;gap:8px;flex-wrap:wrap}
    .miniBtns button{padding:8px 10px;font-size:12px}
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="title">
      <h1>VJ Mixer</h1>
      <div class="sub">
        Two modes: <b>Link Mixer</b> (YouTube URLs, no FX) and <b>FX Capture</b> (tab/window capture, real FX).
        Capture requires a tap and the browser picker.
      </div>
    </div>
    <div class="actions">
      <div class="seg" role="tablist" aria-label="Mode">
        <button id="tabLinks" class="active" role="tab">Link Mixer</button>
        <button id="tabFX" role="tab">FX Capture</button>
      </div>
      <button id="btnPlay" class="primary">Play</button>
      <button id="btnPause">Pause</button>
      <button id="btnFullscreen">Fullscreen</button>
      <button id="btnToggleControls">Show Controls</button>
    </div>
  </div>

  <div class="stage" id="stage">
    <div class="fsHud" id="fsHud">
      <button id="hudPlay">Play</button>
      <button id="hudExit">Exit</button>
    </div>

    <!-- Link mixer layers (iframes) -->
    <div class="layersRoot" id="layersRoot"></div>

    <!-- FX output -->
    <canvas id="fxOut"></canvas>

    <div class="gate" id="gate">
      <button id="gateBtn" class="primary">Tap to Start</button>
    </div>
  </div>

  <div class="controls" id="controls">
    <div class="controlsHead">
      <div class="left">
        <span class="badge" id="modeBadge">Mode: Link Mixer</span>
        <div class="pillrow">
          <span class="pill">Dark UI</span>
          <span class="pill">2–5 links</span>
          <span class="pill">FX are only in Capture mode</span>
        </div>
      </div>
      <div class="small" id="status">Status: idle</div>
    </div>

    <div class="controlsBody" id="controlsBody">
      <!-- MODE: LINKS -->
      <div class="modeBlock active" id="modeLinks">
        <div class="grid">
          <div class="card">
            <div class="cardHead">
              <div class="cardTitle">Links (2–5)</div>
              <div class="miniBtns">
                <button id="addLayer">Add</button>
                <button id="removeLayer" class="danger">Remove</button>
                <button id="reloadLinks">Reload</button>
              </div>
            </div>
            <div class="cardBody">
              <label>Tap-through YouTube UI
                <select id="tapUI">
                  <option value="off" selected>off (recommended)</option>
                  <option value="on">on</option>
                </select>
              </label>
              <div class="small">
                In Link Mixer mode, FX are not possible on YouTube pixels. This mode is a stable multi-link blend stack.
              </div>
              <div class="layerList" id="layerList"></div>
            </div>
          </div>

          <div class="card">
            <div class="cardHead"><div class="cardTitle">Mixer Tips</div></div>
            <div class="cardBody">
              <div class="small">
                • Autoplay often requires a tap. Use “Tap to Start” if you see a black screen.<br/>
                • Keep Tap-through UI off to reduce YouTube overlays/controls popping up.<br/>
                • Use Difference + Invert on upper layers for “VJ-ish” looks without pixel FX.
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- MODE: FX CAPTURE -->
      <div class="modeBlock" id="modeFX">
        <div class="grid">
          <div class="card">
            <div class="cardHead">
              <div class="cardTitle">Capture Sources (Tab/Window)</div>
              <div class="miniBtns">
                <button id="capA" class="primary">Capture A</button>
                <button id="capB" class="primary">Capture B</button>
                <button id="stopCap">Stop Capture</button>
              </div>
            </div>
            <div class="cardBody">
              <div class="small">
                Use the browser picker to choose a <b>YouTube tab</b> or a <b>window</b> for A and B.
                If your browser won’t allow two captures, capture A only and mirror/feedback it for B-like layering.
                Some protected videos may appear black depending on OS/browser/video.
              </div>

              <div class="row">
                <label>Blend (B over A)
                  <select id="fxBlend">
                    <option value="difference" selected>difference</option>
                    <option value="screen">screen</option>
                    <option value="add">add</option>
                    <option value="multiply">multiply</option>
                    <option value="overlay">overlay</option>
                    <option value="exclusion">exclusion</option>
                    <option value="normal">normal</option>
                  </select>
                </label>
                <label>B Opacity
                  <input id="fxBOpacity" type="range" min="0" max="1" step="0.01" value="0.85">
                </label>
              </div>

              <div class="row">
                <label>Invert B
                  <input id="fxInvB" type="range" min="0" max="1" step="0.01" value="1">
                </label>
                <label>Exposure
                  <input id="fxExposure" type="range" min="0.5" max="2.5" step="0.01" value="1.05">
                </label>
              </div>

              <div class="row">
                <label>Contrast
                  <input id="fxContrast" type="range" min="0.5" max="3.0" step="0.01" value="1.35">
                </label>
                <label>Saturation
                  <input id="fxSat" type="range" min="0" max="3" step="0.01" value="1.25">
                </label>
              </div>
            </div>
          </div>

          <div class="card">
            <div class="cardHead"><div class="cardTitle">FX (Real post-processing)</div></div>
            <div class="cardBody">
              <div class="row">
                <label class="toggle"><input id="tFeedback" type="checkbox"> Feedback / Trails</label>
                <label>Amount
                  <input id="feedbackAmt" type="range" min="0" max="0.98" step="0.001" value="0.88">
                </label>
              </div>
              <div class="row">
                <label>Zoom
                  <input id="feedbackZoom" type="range" min="-0.08" max="0.12" step="0.001" value="0.06">
                </label>
                <label>Rotate
                  <input id="feedbackRot" type="range" min="-2.5" max="2.5" step="0.01" value="0.12">
                </label>
              </div>

              <div class="row">
                <label class="toggle"><input id="tKaleido" type="checkbox"> Kaleido / Mirror</label>
                <label>Segments
                  <input id="kSeg" type="range" min="2" max="16" step="1" value="6">
                </label>
              </div>
              <div class="row">
                <label>Amount
                  <input id="kAmt" type="range" min="0" max="1" step="0.01" value="0.85">
                </label>
                <label>Spin
                  <input id="kSpin" type="range" min="-3" max="3" step="0.01" value="0.35">
                </label>
              </div>

              <div class="row">
                <label class="toggle"><input id="tRGB" type="checkbox"> RGB Shift</label>
                <label>Amount
                  <input id="rgbAmt" type="range" min="0" max="0.05" step="0.0005" value="0.012">
                </label>
              </div>

              <div class="row">
                <label class="toggle"><input id="tGlitch" type="checkbox"> Glitch</label>
                <label>Amount
                  <input id="glitchAmt" type="range" min="0" max="1" step="0.01" value="0.35">
                </label>
              </div>

              <div class="row">
                <label class="toggle"><input id="tPixel" type="checkbox"> Pixelate</label>
                <label>Size
                  <input id="pixSize" type="range" min="1" max="220" step="1" value="70">
                </label>
              </div>

              <div class="row">
                <label class="toggle"><input id="tScan" type="checkbox"> Scanlines</label>
                <label>Amount
                  <input id="scanAmt" type="range" min="0" max="1" step="0.01" value="0.35">
                </label>
              </div>

              <div class="row">
                <label class="toggle"><input id="tVig" type="checkbox"> Vignette</label>
                <label>Amount
                  <input id="vigAmt" type="range" min="0" max="1" step="0.01" value="0.55">
                </label>
              </div>

              <div class="miniBtns">
                <button id="fxAllOff">All FX Off</button>
              </div>

              <div class="small">
                This mode is the “real FX” route: capture pixels → shader them.
                If YouTube shows black, try another video, another browser, or “Entire Screen” capture via a desktop browser.
              </div>
            </div>
          </div>
        </div>
      </div><!-- /modeFX -->
    </div><!-- /controlsBody -->
  </div><!-- /controls -->
</div><!-- /wrap -->

<script>
/* ============================================================
   MODE + UI STATE
============================================================ */
const $ = (id)=>document.getElementById(id);

let currentMode = "links"; // "links" or "fx"
function setMode(mode){
  currentMode = mode;
  $("tabLinks").classList.toggle("active", mode==="links");
  $("tabFX").classList.toggle("active", mode==="fx");
  $("modeLinks").classList.toggle("active", mode==="links");
  $("modeFX").classList.toggle("active", mode==="fx");

  $("modeBadge").textContent = mode==="links" ? "Mode: Link Mixer" : "Mode: FX Capture";
  $("layersRoot").style.display = mode==="links" ? "block" : "none";
  $("fxOut").style.display = mode==="fx" ? "block" : "none";
  $("status").textContent = "Status: " + (mode==="links" ? "Link Mixer ready" : "FX Capture ready");
}

$("tabLinks").addEventListener("click", ()=>setMode("links"));
$("tabFX").addEventListener("click", ()=>setMode("fx"));

const controls = $("controls");
$("btnToggleControls").addEventListener("click", ()=>{
  controls.classList.toggle("open");
  $("btnToggleControls").textContent = controls.classList.contains("open") ? "Hide Controls" : "Show Controls";
});
controls.classList.remove("open");
$("btnToggleControls").textContent = "Show Controls";

/* ============================================================
   FULLSCREEN (real + pseudo fallback)
============================================================ */
function canRealFullscreen(){
  return !!($("stage").requestFullscreen && document.fullscreenEnabled);
}
async function toggleFullscreen(){
  const stage = $("stage");
  if (document.body.classList.contains("pseudo-fs")){
    document.body.classList.remove("pseudo-fs");
    return;
  }
  if (canRealFullscreen()){
    try{
      if (document.fullscreenElement) await document.exitFullscreen();
      else await stage.requestFullscreen();
      return;
    }catch(e){}
  }
  document.body.classList.add("pseudo-fs");
}
$("btnFullscreen").addEventListener("click", toggleFullscreen);
$("hudExit").addEventListener("click", toggleFullscreen);

/* ============================================================
   TRANSPORT
============================================================ */
$("btnPlay").addEventListener("click", ()=>playAll());
$("btnPause").addEventListener("click", ()=>pauseAll());
$("hudPlay").addEventListener("click", ()=>playAll());
$("gateBtn").addEventListener("click", ()=>playAll());

function showGate(show){
  $("gate").classList.toggle("show", !!show);
}

/* ============================================================
   MODE 1: LINK MIXER (YouTube iframes, no FX)
============================================================ */
const DEFAULT_LINKS = [
  "https://m.youtube.com/watch?v=3pxrECZYEAA",
  "https://m.youtube.com/watch?v=dS-MaUk6YBI"
];
const BLENDS = [
  "normal","multiply","screen","overlay","darken","lighten","color-dodge","color-burn",
  "hard-light","soft-light","difference","exclusion","hue","saturation","color","luminosity"
];

let linkLayerCount = 2;
const linkLayers = []; // {el, ui, url}
function extractVideoId(url){
  if (!url) return null;
  const raw = url.trim();
  if (/^[a-zA-Z0-9_-]{11}$/.test(raw)) return raw;
  try{
    const u = new URL(raw);
    if (u.hostname.includes("youtu.be")) return u.pathname.replace("/","") || null;
    const v = u.searchParams.get("v");
    if (v) return v;
    const parts = u.pathname.split("/").filter(Boolean);
    const idx = parts.indexOf("embed");
    if (idx>=0 && parts[idx+1]) return parts[idx+1];
  }catch(e){}
  return null;
}
function buildEmbedSrc(videoId){
  const origin = encodeURIComponent(location.origin);
  // best effort UI suppression
  return `https://www.youtube-nocookie.com/embed/${videoId}?enablejsapi=0&playsinline=1&autoplay=1&mute=1&controls=0&rel=0&modestbranding=1&iv_load_policy=3&fs=0&disablekb=1&origin=${origin}`;
}
function fillBlendOptions(sel, def="difference"){
  sel.innerHTML = BLENDS.map(b=>`<option value="${b}">${b}</option>`).join("");
  sel.value = def;
}
function makeLinkLayer(i){
  const el = document.createElement("div");
  el.className = "layer";
  el.style.zIndex = String(10 + i);
  $("layersRoot").appendChild(el);
  return el;
}
function applyLinkStyle(i){
  const L = linkLayers[i];
  if (!L) return;
  const tap = $("tapUI").value === "on";
  L.el.style.pointerEvents = tap ? "auto" : "none";
  L.el.style.opacity = L.ui.op;
  L.el.style.mixBlendMode = L.ui.blend;
  L.el.style.filter = `invert(${L.ui.inv}) contrast(${L.ui.ct}) saturate(${L.ui.sat}) hue-rotate(${L.ui.hue}deg)`;
}
function mountLinkIframe(i){
  const L = linkLayers[i];
  const vid = extractVideoId(L.url);
  if (!vid){
    L.el.innerHTML = "";
    return;
  }
  const src = buildEmbedSrc(vid);
  L.el.innerHTML = `<iframe allow="autoplay; encrypted-media; picture-in-picture" allowfullscreen="false" src="${src}"></iframe>`;
}
function rebuildLinkUI(){
  const list = $("layerList");
  list.innerHTML = "";

  for (let i=0;i<linkLayerCount;i++){
    const item = document.createElement("div");
    item.className = "layerItem";
    item.innerHTML = `
      <div class="layerItemHead">
        <div class="name">Layer ${i+1}</div>
        <div class="miniBtns">
          <button data-act="apply" data-i="${i}">Apply</button>
        </div>
      </div>
      <div class="layerItemBody">
        <label>YouTube URL or ID
          <input type="text" data-f="url" data-i="${i}"/>
        </label>
        <div class="row">
          <label>Opacity
            <input type="range" min="0" max="1" step="0.01" data-f="op" data-i="${i}"/>
          </label>
          <label>Blend
            <select data-f="blend" data-i="${i}"></select>
          </label>
        </div>
        <div class="row">
          <label>Invert
            <input type="range" min="0" max="1" step="0.01" data-f="inv" data-i="${i}"/>
          </label>
          <label>Contrast
            <input type="range" min="0.5" max="3" step="0.01" data-f="ct" data-i="${i}"/>
          </label>
        </div>
        <div class="row">
          <label>Saturation
            <input type="range" min="0" max="3" step="0.01" data-f="sat" data-i="${i}"/>
          </label>
          <label>Hue rotate
            <input type="range" min="-180" max="180" step="1" data-f="hue" data-i="${i}"/>
          </label>
        </div>
      </div>
    `;
    list.appendChild(item);

    // seed defaults
    const L = linkLayers[i];
    item.querySelector(`[data-f="url"][data-i="${i}"]`).value = L.url;

    item.querySelector(`[data-f="op"][data-i="${i}"]`).value = L.ui.op;
    item.querySelector(`[data-f="inv"][data-i="${i}"]`).value = L.ui.inv;
    item.querySelector(`[data-f="ct"][data-i="${i}"]`).value = L.ui.ct;
    item.querySelector(`[data-f="sat"][data-i="${i}"]`).value = L.ui.sat;
    item.querySelector(`[data-f="hue"][data-i="${i}"]`).value = L.ui.hue;

    const sel = item.querySelector(`select[data-f="blend"][data-i="${i}"]`);
    fillBlendOptions(sel, L.ui.blend);
  }
}
function rebuildLinkLayers(){
  $("layersRoot").innerHTML = "";
  linkLayers.length = 0;
  for (let i=0;i<linkLayerCount;i++){
    const el = makeLinkLayer(i);
    linkLayers.push({
      el,
      url: DEFAULT_LINKS[i] || DEFAULT_LINKS[1],
      ui: {
        op: i===0 ? 1 : 0.85,
        blend: i===0 ? "normal" : "difference",
        inv: i===0 ? 0 : 1,
        ct: i===0 ? 1 : 1.6,
        sat: i===0 ? 1 : 1.2,
        hue: 0
      }
    });
    mountLinkIframe(i);
    applyLinkStyle(i);
  }
  rebuildLinkUI();
}
$("addLayer").addEventListener("click", ()=>{
  if (linkLayerCount>=5) return;
  linkLayerCount++;
  rebuildLinkLayers();
});
$("removeLayer").addEventListener("click", ()=>{
  if (linkLayerCount<=2) return;
  linkLayerCount--;
  rebuildLinkLayers();
});
$("reloadLinks").addEventListener("click", ()=>{
  for (let i=0;i<linkLayerCount;i++){
    mountLinkIframe(i);
    applyLinkStyle(i);
  }
});
$("tapUI").addEventListener("change", ()=>{
  for (let i=0;i<linkLayerCount;i++) applyLinkStyle(i);
});
$("layerList").addEventListener("input", (e)=>{
  const t = e.target;
  const i = parseInt(t.getAttribute("data-i"), 10);
  const f = t.getAttribute("data-f");
  if (Number.isNaN(i) || !f) return;

  const L = linkLayers[i];
  if (!L) return;
  if (f==="url") L.url = t.value;
  if (f==="op") L.ui.op = parseFloat(t.value);
  if (f==="blend") L.ui.blend = t.value;
  if (f==="inv") L.ui.inv = parseFloat(t.value);
  if (f==="ct") L.ui.ct = parseFloat(t.value);
  if (f==="sat") L.ui.sat = parseFloat(t.value);
  if (f==="hue") L.ui.hue = parseInt(t.value, 10);

  applyLinkStyle(i);
});
$("layerList").addEventListener("click", (e)=>{
  const btn = e.target.closest("button[data-act]");
  if (!btn) return;
  const act = btn.getAttribute("data-act");
  const i = parseInt(btn.getAttribute("data-i"), 10);
  if (act==="apply"){
    mountLinkIframe(i);
    applyLinkStyle(i);
  }
});

/* ============================================================
   MODE 2: FX CAPTURE (Tab/Window capture → WebGL FX)
============================================================ */
let capStreamA = null, capStreamB = null;
const capVideoA = document.createElement("video");
const capVideoB = document.createElement("video");
capVideoA.muted = true; capVideoB.muted = true;
capVideoA.playsInline = true; capVideoB.playsInline = true;

async function startCapture(which){
  // which: "A" or "B"
  try{
    const stream = await navigator.mediaDevices.getDisplayMedia({
      video: { frameRate: 60 },
      audio: false
    });
    if (which==="A"){
      capStreamA = stream;
      capVideoA.srcObject = stream;
      await capVideoA.play();
    } else {
      capStreamB = stream;
      capVideoB.srcObject = stream;
      await capVideoB.play();
    }
    $("status").textContent = `Status: captured ${which} (choose a Tab or Window)`;
    showGate(false);
  }catch(e){
    $("status").textContent = `Status: capture ${which} canceled/blocked`;
  }
}

function stopCaptureAll(){
  for (const s of [capStreamA, capStreamB]){
    if (!s) continue;
    for (const tr of s.getTracks()) tr.stop();
  }
  capStreamA = null; capStreamB = null;
  capVideoA.srcObject = null; capVideoB.srcObject = null;
  $("status").textContent = "Status: capture stopped";
}

$("capA").addEventListener("click", ()=>startCapture("A"));
$("capB").addEventListener("click", ()=>startCapture("B"));
$("stopCap").addEventListener("click", stopCaptureAll);

// FX toggles helper
$("fxAllOff").addEventListener("click", ()=>{
  $("tFeedback").checked = false;
  $("tKaleido").checked = false;
  $("tRGB").checked = false;
  $("tGlitch").checked = false;
  $("tPixel").checked = false;
  $("tScan").checked = false;
  $("tVig").checked = false;
});

/* ============================================================
   PLAY / PAUSE for both modes
============================================================ */
function playAll(){
  if (currentMode==="links"){
    // if autoplay blocked, show gate
    showGate(true);
    // iframes manage themselves; gate is just UX
    setTimeout(()=>showGate(false), 900);
  } else {
    // ensure capture videos play
    if (capVideoA.srcObject) capVideoA.play().catch(()=>{});
    if (capVideoB.srcObject) capVideoB.play().catch(()=>{});
  }
}
function pauseAll(){
  if (currentMode==="fx"){
    capVideoA.pause(); capVideoB.pause();
  }
}

/* ============================================================
   WebGL FX Pipeline (2 inputs + feedback buffer)
============================================================ */
const canvas = $("fxOut");
let gl = null;
let prog = null;
let quadVBO = null;
let texA = null, texB = null;
let fbTex0 = null, fbTex1 = null;
let fbFbo0 = null, fbFbo1 = null;
let ping = 0;

function createShader(gl, type, src){
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(sh));
    gl.deleteShader(sh);
    return null;
  }
  return sh;
}
function createProgram(gl, vsSrc, fsSrc){
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
  if (!vs || !fs) return null;
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(p));
    gl.deleteProgram(p);
    return null;
  }
  gl.deleteShader(vs); gl.deleteShader(fs);
  return p;
}

const VS = `
attribute vec2 aPos;
varying vec2 vUv;
void main(){
  vUv = aPos*0.5 + 0.5;
  gl_Position = vec4(aPos, 0.0, 1.0);
}
`;

// Fragment shader: mix A/B, apply FX, write to screen OR feedback buffer
const FS = `
precision highp float;
varying vec2 vUv;

uniform sampler2D uA;
uniform sampler2D uB;
uniform sampler2D uFB;
uniform vec2 uRes;
uniform float uTime;

uniform int uHasA;
uniform int uHasB;

uniform int uBlendMode;
uniform float uBOpacity;
uniform float uInvB;
uniform float uExposure;
uniform float uContrast;
uniform float uSat;

uniform int uFeedbackOn;
uniform float uFbAmt;
uniform float uFbZoom;
uniform float uFbRot;

uniform int uKaleidoOn;
uniform float uKSeg;
uniform float uKAmt;
uniform float uKSpin;

uniform int uRGBOn;
uniform float uRGBAmt;

uniform int uGlitchOn;
uniform float uGlitchAmt;

uniform int uPixelOn;
uniform float uPixSize;

uniform int uScanOn;
uniform float uScanAmt;

uniform int uVigOn;
uniform float uVigAmt;

vec3 satAdjust(vec3 c, float s){
  float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
  return mix(vec3(l), c, s);
}

vec2 rot(vec2 p, float a){
  float c = cos(a), s = sin(a);
  return mat2(c,-s,s,c) * p;
}

// blend modes (limited set)
vec3 blend(vec3 a, vec3 b, int mode){
  if (mode==0) return b;                          // normal
  if (mode==1) return a*b;                        // multiply
  if (mode==2) return 1.0 - (1.0-a)*(1.0-b);      // screen
  if (mode==3) return abs(a-b);                   // difference
  if (mode==4) return a + b;                      // add
  if (mode==5) return mix(2.0*a*b, 1.0-2.0*(1.0-a)*(1.0-b), step(0.5,a)); // overlay-ish
  if (mode==6) return a + b - 2.0*a*b;            // exclusion-ish
  return b;
}

float hash(vec2 p){
  p = fract(p*vec2(123.34,456.21));
  p += dot(p, p+34.345);
  return fract(p.x*p.y);
}

void main(){
  vec2 uv = vUv;

  // Pixelate
  if (uPixelOn==1){
    float px = max(1.0, uPixSize);
    uv = floor(uv*px)/px + 0.5/px;
  }

  // Fetch inputs
  vec3 A = (uHasA==1) ? texture2D(uA, uv).rgb : vec3(0.0);
  vec3 B = (uHasB==1) ? texture2D(uB, uv).rgb : vec3(0.0);

  // Invert B (0..1)
  B = mix(B, 1.0 - B, clamp(uInvB,0.0,1.0));

  // RGB shift (applied to B primarily)
  if (uRGBOn==1 && uHasB==1){
    float amt = uRGBAmt;
    vec2 off = vec2(amt, 0.0);
    float r = texture2D(uB, uv + off).r;
    float g = texture2D(uB, uv).g;
    float b = texture2D(uB, uv - off).b;
    vec3 rgb = vec3(r,g,b);
    rgb = mix(rgb, 1.0-rgb, clamp(uInvB,0.0,1.0));
    B = rgb;
  }

  // Glitch (scanline jitter + block swap)
  if (uGlitchOn==1){
    float g = uGlitchAmt;
    float t = uTime*1.2;
    float line = floor(uv.y*240.0);
    float rnd = hash(vec2(line, floor(t*6.0)));
    float jitter = (rnd-0.5)*0.02*g;
    uv.x += jitter;

    float blockY = floor(uv.y*10.0);
    float br = hash(vec2(blockY, floor(t*3.0)));
    if (br < 0.18*g){
      uv.x += (br-0.09)*0.12*g;
    }

    // refetch after glitch
    A = (uHasA==1) ? texture2D(uA, uv).rgb : vec3(0.0);
    B = (uHasB==1) ? texture2D(uB, uv).rgb : vec3(0.0);
    B = mix(B, 1.0 - B, clamp(uInvB,0.0,1.0));
  }

  // Kaleido (apply to combined base after blend for stronger look)
  vec3 base = A;
  int mode = uBlendMode;
  vec3 mixedB = blend(A, B, mode);
  base = mix(A, mixedB, clamp(uBOpacity,0.0,1.0));

  // Feedback buffer (pre-color)
  vec2 p = vUv - 0.5;
  vec2 fbUv = vUv;
  if (uFeedbackOn==1){
    float a = uFbRot;
    float z = 1.0 + uFbZoom;
    vec2 rp = rot(p, a) / z;
    fbUv = rp + 0.5;
    vec3 fb = texture2D(uFB, fbUv).rgb;
    base = mix(base, fb, clamp(uFbAmt,0.0,0.98));
  }

  // Kaleido transform
  if (uKaleidoOn==1){
    vec2 kp = vUv - 0.5;
    float ang = atan(kp.y, kp.x);
    float r = length(kp);
    float seg = max(2.0, uKSeg);
    float k = 6.28318530718 / seg;
    ang = mod(ang + uTime*uKSpin, k);
    ang = abs(ang - k*0.5);
    vec2 ku = vec2(cos(ang), sin(ang)) * r;
    vec2 uvk = ku + 0.5;
    vec3 kcol = vec3(0.0);
    if (uHasA==1) kcol += texture2D(uA, uvk).rgb;
    if (uHasB==1) {
      vec3 bb = texture2D(uB, uvk).rgb;
      bb = mix(bb, 1.0-bb, clamp(uInvB,0.0,1.0));
      kcol = blend(kcol, bb, mode);
    }
    base = mix(base, kcol, clamp(uKAmt,0.0,1.0));
  }

  // Exposure/contrast/sat
  base *= uExposure;
  base = (base - 0.5)*uContrast + 0.5;
  base = satAdjust(base, uSat);

  // Scanlines
  if (uScanOn==1){
    float s = sin(vUv.y*uRes.y*3.14159);
    float scan = mix(1.0, 0.78 + 0.22*s, clamp(uScanAmt,0.0,1.0));
    base *= scan;
  }

  // Vignette
  if (uVigOn==1){
    float d = distance(vUv, vec2(0.5));
    float v = smoothstep(0.35, 0.95, d);
    base *= mix(1.0, 1.0 - v, clamp(uVigAmt,0.0,1.0));
  }

  gl_FragColor = vec4(clamp(base, 0.0, 1.0), 1.0);
}
`;

function resizeCanvas(){
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(2, Math.floor(rect.width*dpr));
  const h = Math.max(2, Math.floor(rect.height*dpr));
  if (canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
    if (gl){
      gl.viewport(0,0,w,h);
      initFeedbackTextures(w,h);
    }
  }
}

function makeTex(){
  const t = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, t);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return t;
}

function initFeedbackTextures(w,h){
  // (re)create feedback ping-pong textures & fbos
  function makeFBTex(){
    const t = makeTex();
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
    return t;
  }
  function makeFBO(tex){
    const f = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, f);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return f;
  }

  // cleanup old
  [fbTex0, fbTex1].forEach(t=>t && gl.deleteTexture(t));
  [fbFbo0, fbFbo1].forEach(f=>f && gl.deleteFramebuffer(f));

  fbTex0 = makeFBTex();
  fbTex1 = makeFBTex();
  fbFbo0 = makeFBO(fbTex0);
  fbFbo1 = makeFBO(fbTex1);
  ping = 0;
}

function initGL(){
  gl = canvas.getContext("webgl", { antialias:false, alpha:false, preserveDrawingBuffer:false });
  if (!gl){
    $("status").textContent = "Status: WebGL not supported";
    return;
  }
  prog = createProgram(gl, VS, FS);
  if (!prog){
    $("status").textContent = "Status: shader compile failed";
    return;
  }
  gl.useProgram(prog);

  quadVBO = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  1,-1, -1, 1,
    -1, 1,  1,-1,  1, 1
  ]), gl.STATIC_DRAW);

  const aPos = gl.getAttribLocation(prog, "aPos");
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

  texA = makeTex();
  texB = makeTex();

  resizeCanvas();
}

function blendModeToInt(v){
  // matches shader: normal=0 multiply=1 screen=2 difference=3 add=4 overlay-ish=5 exclusion-ish=6
  if (v==="normal") return 0;
  if (v==="multiply") return 1;
  if (v==="screen") return 2;
  if (v==="difference") return 3;
  if (v==="add") return 4;
  if (v==="overlay") return 5;
  if (v==="exclusion") return 6;
  return 3;
}

function updateVideoTexture(tex, video){
  gl.bindTexture(gl.TEXTURE_2D, tex);
  try{
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
  }catch(e){
    // Ignore frames not ready
  }
  gl.bindTexture(gl.TEXTURE_2D, null);
}

function renderFX(timeMs){
  if (!gl || currentMode!=="fx") return;
  resizeCanvas();

  const hasA = !!capStreamA && capVideoA.readyState >= 2;
  const hasB = !!capStreamB && capVideoB.readyState >= 2;

  if (hasA) updateVideoTexture(texA, capVideoA);
  if (hasB) updateVideoTexture(texB, capVideoB);

  gl.useProgram(prog);

  const w = canvas.width, h = canvas.height;

  // bind input textures
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texA);
  gl.uniform1i(gl.getUniformLocation(prog,"uA"), 0);

  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, texB);
  gl.uniform1i(gl.getUniformLocation(prog,"uB"), 1);

  // feedback texture is previous ping
  const prevTex = (ping===0) ? fbTex0 : fbTex1;
  const nextFbo = (ping===0) ? fbFbo1 : fbFbo0;
  gl.activeTexture(gl.TEXTURE2);
  gl.bindTexture(gl.TEXTURE_2D, prevTex);
  gl.uniform1i(gl.getUniformLocation(prog,"uFB"), 2);

  gl.uniform2f(gl.getUniformLocation(prog,"uRes"), w, h);
  gl.uniform1f(gl.getUniformLocation(prog,"uTime"), timeMs/1000);

  gl.uniform1i(gl.getUniformLocation(prog,"uHasA"), hasA ? 1 : 0);
  gl.uniform1i(gl.getUniformLocation(prog,"uHasB"), hasB ? 1 : 0);

  // mixer uniforms
  gl.uniform1i(gl.getUniformLocation(prog,"uBlendMode"), blendModeToInt($("fxBlend").value));
  gl.uniform1f(gl.getUniformLocation(prog,"uBOpacity"), parseFloat($("fxBOpacity").value));
  gl.uniform1f(gl.getUniformLocation(prog,"uInvB"), parseFloat($("fxInvB").value));
  gl.uniform1f(gl.getUniformLocation(prog,"uExposure"), parseFloat($("fxExposure").value));
  gl.uniform1f(gl.getUniformLocation(prog,"uContrast"), parseFloat($("fxContrast").value));
  gl.uniform1f(gl.getUniformLocation(prog,"uSat"), parseFloat($("fxSat").value));

  // fx toggles
  gl.uniform1i(gl.getUniformLocation(prog,"uFeedbackOn"), $("tFeedback").checked ? 1 : 0);
  gl.uniform1f(gl.getUniformLocation(prog,"uFbAmt"), parseFloat($("feedbackAmt").value));
  gl.uniform1f(gl.getUniformLocation(prog,"uFbZoom"), parseFloat($("feedbackZoom").value));
  gl.uniform1f(gl.getUniformLocation(prog,"uFbRot"), parseFloat($("feedbackRot").value));

  gl.uniform1i(gl.getUniformLocation(prog,"uKaleidoOn"), $("tKaleido").checked ? 1 : 0);
  gl.uniform1f(gl.getUniformLocation(prog,"uKSeg"), parseFloat($("kSeg").value));
  gl.uniform1f(gl.getUniformLocation(prog,"uKAmt"), parseFloat($("kAmt").value));
  gl.uniform1f(gl.getUniformLocation(prog,"uKSpin"), parseFloat($("kSpin").value));

  gl.uniform1i(gl.getUniformLocation(prog,"uRGBOn"), $("tRGB").checked ? 1 : 0);
  gl.uniform1f(gl.getUniformLocation(prog,"uRGBAmt"), parseFloat($("rgbAmt").value));

  gl.uniform1i(gl.getUniformLocation(prog,"uGlitchOn"), $("tGlitch").checked ? 1 : 0);
  gl.uniform1f(gl.getUniformLocation(prog,"uGlitchAmt"), parseFloat($("glitchAmt").value));

  gl.uniform1i(gl.getUniformLocation(prog,"uPixelOn"), $("tPixel").checked ? 1 : 0);
  gl.uniform1f(gl.getUniformLocation(prog,"uPixSize"), parseFloat($("pixSize").value));

  gl.uniform1i(gl.getUniformLocation(prog,"uScanOn"), $("tScan").checked ? 1 : 0);
  gl.uniform1f(gl.getUniformLocation(prog,"uScanAmt"), parseFloat($("scanAmt").value));

  gl.uniform1i(gl.getUniformLocation(prog,"uVigOn"), $("tVig").checked ? 1 : 0);
  gl.uniform1f(gl.getUniformLocation(prog,"uVigAmt"), parseFloat($("vigAmt").value));

  // 1) render to feedback nextFbo
  gl.bindFramebuffer(gl.FRAMEBUFFER, nextFbo);
  gl.viewport(0,0,w,h);
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  // 2) render to screen using the same shader but with updated feedback (swap)
  ping = 1 - ping;
  const nowTex = (ping===0) ? fbTex0 : fbTex1;

  gl.activeTexture(gl.TEXTURE2);
  gl.bindTexture(gl.TEXTURE_2D, nowTex);

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0,0,w,h);
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  requestAnimationFrame(renderFX);
}

/* ============================================================
   BOOT
============================================================ */
function boot(){
  initGL();
  rebuildLinkLayers();
  setMode("links");
  requestAnimationFrame(renderFX);

  // try to help autoplay UX
  showGate(false);
  setTimeout(()=>showGate(true), 600);
  setTimeout(()=>showGate(false), 1500);
}
window.addEventListener("resize", ()=>resizeCanvas());
document.addEventListener("DOMContentLoaded", boot);
</script>
</body>
</html>
