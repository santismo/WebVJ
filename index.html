<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>YouTube Overlay VJ (Echo Post FX)</title>
  <style>
    :root{
      --bg:#07080c;
      --panel:#0f1118;
      --panel2:#0b0d13;
      --text:#eef1f7;
      --muted:#a9b0bf;
      --border:rgba(255,255,255,.10);
      --accent:#7aa2ff;
      --maxw:1100px;
      --radius:14px;
    }
    html,body{background:var(--bg); color:var(--text); margin:0; font-family:system-ui,-apple-system,sans-serif;}
    .wrap{max-width:var(--maxw); margin:18px auto; padding:0 14px; display:grid; gap:12px;}
    h1{font-size:18px; margin:0;}
    .topbar{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;}
    .btnrow{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    button{
      background:var(--panel);
      color:var(--text);
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      font-size:15px;
    }
    button.primary{
      border-color:rgba(122,162,255,.55);
      box-shadow:0 0 0 2px rgba(122,162,255,.10) inset;
    }
    button.ghost{background:transparent}
    .hint{font-size:12px; color:var(--muted);}

    .stage{
      position:relative;
      width:min(96vw,var(--maxw));
      aspect-ratio:16/9;
      border-radius:var(--radius);
      overflow:hidden;
      background:#000;
      border:1px solid var(--border);
    }
    .stage:fullscreen{
      width:100vw; height:100vh; aspect-ratio:auto;
      border-radius:0; border:none;
    }

    /* IMPORTANT: base + overlay must never be display:none (YT sizing issues). */
    .layer{
      position:absolute; inset:0;
      transform-origin:50% 50%;
      pointer-events:none;
      will-change: transform, filter, opacity;
      display:block;
      opacity:1;
    }
    .layer.base{pointer-events:auto;}
    .layer iframe{width:100%; height:100%; border:0; display:block;}

    /* Only post layers get hidden via .hidden */
    .hidden{display:none !important;}

    .playOverlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      background:linear-gradient(to bottom, rgba(0,0,0,.20), rgba(0,0,0,.65));
      backdrop-filter: blur(2px);
      opacity:0; pointer-events:none;
      transition:opacity .2s ease;
      z-index:30;
    }
    .playOverlay.show{opacity:1; pointer-events:auto;}
    .playOverlay button{
      font-size:16px;
      padding:12px 16px;
      border-radius:999px;
      background:rgba(15,17,24,.75);
      border:1px solid rgba(122,162,255,.6);
    }

    /* iOS-friendly pseudo fullscreen */
    body.pseudo-fs{ overflow:hidden; }
    body.pseudo-fs .wrap{ max-width:none; margin:0; padding:0; }
    body.pseudo-fs .topbar, body.pseudo-fs #controlsPanel{ display:none; }
    body.pseudo-fs .stage{
      position:fixed; inset:0; width:100vw; height:100vh;
      border-radius:0; border:none; aspect-ratio:auto;
      z-index:9999;
    }
    body.pseudo-fs .fsHud{ display:flex; }

    .fsHud{
      position:absolute; top:10px; right:10px; left:10px;
      display:none; justify-content:space-between; gap:10px;
      z-index:40; pointer-events:none;
    }
    .fsHud .hudBtn{
      pointer-events:auto;
      background:rgba(15,17,24,.65);
      border:1px solid rgba(255,255,255,.18);
      border-radius:999px;
      padding:9px 12px;
      font-size:14px;
      backdrop-filter: blur(6px);
    }

    .panel{
      background:var(--panel2);
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
    }
    .panelHead{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px; gap:10px;
      border-bottom:1px solid var(--border);
    }
    .panelBody{padding:12px; display:none;}
    .panel.open .panelBody{display:block;}
    .mini{display:flex; gap:8px; flex-wrap:wrap; align-items:center; color:var(--muted); font-size:12px;}
    .pill{
      border:1px solid var(--border);
      padding:3px 8px;
      border-radius:999px;
      background:rgba(255,255,255,.03);
    }

    .card{
      border:1px solid var(--border);
      border-radius:var(--radius);
      background:rgba(255,255,255,.02);
      overflow:hidden;
      margin-bottom:12px;
    }
    .cardHead{
      padding:10px 12px;
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
      border-bottom:1px solid var(--border);
    }
    .cardTitle{font-weight:700; font-size:14px;}
    .row{
      display:grid; gap:10px;
      grid-template-columns:1fr 1fr;
      padding:12px;
    }
    @media (max-width:820px){ .row{grid-template-columns:1fr;} }
    label{display:grid; gap:6px; font-size:13px; color:var(--muted);}
    input[type="text"], select{
      width:100%;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.30);
      color:var(--text);
      font-size:15px;
      outline:none;
    }
    input[type="range"]{width:100%;}
    .toggle{display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px; user-select:none;}
    .toggle input{transform:scale(1.05)}
    .btnGroup{display:flex; gap:10px; flex-wrap:wrap; padding:12px;}
    .btnGroup button{padding:9px 11px; font-size:14px;}
    .small{font-size:12px; color:var(--muted);}
    .divider{height:1px; background:var(--border); margin:0 12px;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>YouTube Overlay VJ</h1>
        <div class="hint">
          Defaults: overlay blend=<b>difference</b> + invert=<b>max</b>. Post FX presets are OFF by default.
        </div>
      </div>
      <div class="btnrow">
        <button id="reloadBtn" class="ghost">Reload</button>
        <button id="playBtn" class="primary">Play</button>
        <button id="pauseBtn">Pause</button>
        <button id="fsBtn">Full screen</button>
        <button id="controlsBtn">Expand controls</button>
      </div>
    </div>

    <div class="stage" id="stage">
      <div class="fsHud" id="fsHud">
        <button class="hudBtn" id="hudPlay">Play</button>
        <button class="hudBtn" id="hudExit">Exit</button>
      </div>

      <!-- 0=base, 1=overlay, 2-4=post FX echoes -->
      <div id="layer0" class="layer base"></div>
      <div id="layer1" class="layer"></div>
      <div id="layer2" class="layer hidden"></div>
      <div id="layer3" class="layer hidden"></div>
      <div id="layer4" class="layer hidden"></div>

      <div class="playOverlay" id="playOverlay">
        <button id="tapPlayBtn">Tap to Play</button>
      </div>
    </div>

    <div class="panel" id="controlsPanel">
      <div class="panelHead">
        <div class="mini">
          <span class="pill">2 main layers</span>
          <span class="pill">+3 post FX echo layers</span>
          <span class="pill">iOS pseudo-fullscreen fallback</span>
        </div>
        <div class="btnrow">
          <button id="hidePanelBtn" class="ghost">Hide</button>
        </div>
      </div>

      <div class="panelBody">
        <div class="card">
          <div class="cardHead">
            <div class="cardTitle">Sources</div>
          </div>
          <div class="row">
            <label>Base URL (Layer 1)
              <input id="url0" type="text">
            </label>
            <label>Overlay URL (Layer 2)
              <input id="url1" type="text">
            </label>
          </div>

          <div class="row">
            <label>Base opacity
              <input id="op0" type="range" min="0" max="1" step="0.01" value="1">
            </label>
            <label>Overlay opacity
              <input id="op1" type="range" min="0" max="1" step="0.01" value="0.85">
            </label>
          </div>

          <div class="row">
            <label>Overlay blend mode
              <select id="blend1"></select>
            </label>
            <label>Overlay invert (default max)
              <input id="inv1" type="range" min="0" max="1" step="0.01" value="1">
            </label>
          </div>

          <div class="row">
            <label>Overlay contrast
              <input id="ct1" type="range" min="0.5" max="3.0" step="0.01" value="1.4">
            </label>
            <label>Overlay saturation
              <input id="sat1" type="range" min="0" max="3.0" step="0.01" value="0.9">
            </label>
          </div>

          <div class="btnGroup">
            <button id="muteBaseBtn">Unmute base</button>
            <button id="muteOvBtn">Unmute overlay</button>
          </div>
          <div class="small" style="padding:0 12px 12px;">
            Autoplay is attempted muted. Unmute usually requires a tap. Post FX echoes stay muted.
          </div>
        </div>

        <div class="card">
          <div class="cardHead">
            <div class="cardTitle">Post FX Presets (OFF by default)</div>
            <label class="toggle">
              <input id="postOn" type="checkbox">
              Enable Post FX
            </label>
          </div>

          <div class="btnGroup">
            <button id="presetOff" class="ghost">Clear preset</button>
            <button id="pTrail">Trail Echo</button>
            <button id="pRGB">RGB Shift</button>
            <button id="pGlitchJit">Glitch: Jitter</button>
            <button id="pGlitchPop">Glitch: Pop / Flash</button>
            <button id="pFeedback">Feedback Tunnel</button>
            <button id="pMirror">Mirror / Kaleido-ish</button>
          </div>

          <div class="divider"></div>

          <div class="row">
            <label>Master intensity
              <input id="postAmt" type="range" min="0" max="1" step="0.01" value="0.65">
            </label>
            <label>Echo opacity multiplier
              <input id="echoMul" type="range" min="0" max="2" step="0.01" value="1.0">
            </label>
          </div>

          <div class="row">
            <label>Glitch amount
              <input id="jitAmt" type="range" min="0" max="1" step="0.01" value="0.35">
            </label>
            <label>Glitch speed
              <input id="jitSpd" type="range" min="0" max="40" step="0.5" value="12">
            </label>
          </div>

          <div class="row">
            <label>Feedback zoom base
              <input id="fbZoomBase" type="range" min="1.00" max="1.12" step="0.001" value="1.03">
            </label>
            <label>Feedback zoom step (per echo)
              <input id="fbZoomStep" type="range" min="0.000" max="0.060" step="0.001" value="0.018">
            </label>
          </div>

          <div class="row">
            <label>Feedback rotation speed (deg/sec)
              <input id="fbRotSpd" type="range" min="0" max="90" step="0.5" value="12">
            </label>
            <label>Feedback drift amount (%)
              <input id="fbDriftAmt" type="range" min="0" max="8" step="0.1" value="2.0">
            </label>
          </div>

          <div class="row">
            <label>Feedback drift speed
              <input id="fbDriftSpd" type="range" min="0" max="6" step="0.05" value="1.2">
            </label>
            <label>Feedback blur (px)
              <input id="fbBlur" type="range" min="0" max="10" step="0.1" value="1.4">
            </label>
          </div>

          <div class="row">
            <label>Mirror mode
              <select id="mirMode">
                <option value="none">none</option>
                <option value="mx">mirror X</option>
                <option value="my">mirror Y</option>
                <option value="mxy">mirror X+Y</option>
                <option value="quad">quad (4-way vibe)</option>
              </select>
            </label>
            <label>Mirror rotate (deg)
              <input id="mirRot" type="range" min="-180" max="180" step="1" value="0">
            </label>
          </div>

          <div class="small" style="padding:0 12px 12px;">
            Note: these are “iframe-safe” illusions using extra echo layers (duplicates), not true pixel-feedback.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- YT Iframe API -->
  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    // ---------- Defaults ----------
    const DEFAULT0 = "https://m.youtube.com/watch?v=3pxrECZYEAA&pp=ygUOdmlzdWFscyB0cmlwcHk%3D";
    const DEFAULT1 = "https://m.youtube.com/watch?v=dS-MaUk6YBI";

    const blendModes = [
      "normal","multiply","screen","overlay","darken","lighten","color-dodge","color-burn",
      "hard-light","soft-light","difference","exclusion","hue","saturation","color","luminosity"
    ];

    // Players: 0..4
    const players = new Array(5).fill(null);
    const loadedIds = new Array(5).fill(null);

    let mutedBase = true;
    let mutedOv = true;

    const post = {
      enabled: false,
      preset: "none",
    };

    // Layer config used for CSS transforms/filters
    const cfg = Array.from({length:5}, () => ({
      enabled: false,
      opacity: 1,
      blend: "normal",
      inv: 0,
      ct: 1,
      br: 1,
      sat: 1,
      hue: 0,
      blur: 0,
      x: 0, y: 0,
      scale: 1,
      rot: 0,
      flipX: false,
      flipY: false
    }));

    function extractVideoId(url) {
      if (!url) return null;
      const raw = url.trim();
      if (/^[a-zA-Z0-9_-]{11}$/.test(raw)) return raw;
      try {
        const u = new URL(raw);
        if (u.hostname.includes("youtu.be")) return u.pathname.replace("/", "") || null;
        const v = u.searchParams.get("v");
        if (v) return v;
        const parts = u.pathname.split("/").filter(Boolean);
        const embedIdx = parts.indexOf("embed");
        if (embedIdx >= 0 && parts[embedIdx + 1]) return parts[embedIdx + 1];
      } catch (e) {}
      return null;
    }

    function destroyPlayer(i) {
      try { players[i] && players[i].destroy && players[i].destroy(); } catch(e) {}
      players[i] = null;
      loadedIds[i] = null;
      const layer = document.getElementById(`layer${i}`);
      layer.innerHTML = "";
    }

    function ensureVisibleForYT(i) {
      // Ensure container is visible BEFORE mounting player (prevents 0x0 black).
      const layer = document.getElementById(`layer${i}`);
      layer.classList.remove("hidden");
      layer.style.display = "block";
      layer.style.opacity = "1";
    }

    function mountPlayer(i, videoId) {
      ensureVisibleForYT(i);

      const layer = document.getElementById(`layer${i}`);
      layer.innerHTML = `<div id="player${i}"></div>`;

      const p = new YT.Player(`player${i}`, {
        videoId,
        playerVars: { playsinline: 1, rel: 0 },
        events: {
          onReady: (e) => { try { e.target.mute(); } catch(err) {} }
        }
      });

      players[i] = p;
      loadedIds[i] = videoId;
    }

    function applyLayerCSS(i) {
      const el = document.getElementById(`layer${i}`);
      const c = cfg[i];

      // Base & overlay always visible (0,1). Echo layers toggle.
      if (i <= 1) {
        el.classList.remove("hidden");
      } else {
        el.classList.toggle("hidden", !c.enabled);
      }

      el.style.opacity = c.opacity;
      el.style.mixBlendMode = c.blend;

      const sx = (c.flipX ? -1 : 1);
      const sy = (c.flipY ? -1 : 1);

      el.style.transform =
        `translate(${c.x}%, ${c.y}%) scale(${c.scale * sx}, ${c.scale * sy}) rotate(${c.rot}deg)`;

      el.style.filter =
        `invert(${c.inv}) contrast(${c.ct}) brightness(${c.br}) saturate(${c.sat}) hue-rotate(${c.hue}deg) blur(${c.blur}px)`;
    }

    function applyAllCSS() {
      for (let i=0;i<5;i++) applyLayerCSS(i);
      // layer0 interactive
      for (let i=0;i<5;i++) document.getElementById(`layer${i}`).classList.toggle("base", i===0);
    }

    function setMainFromUI() {
      // base
      cfg[0].enabled = true;
      cfg[0].opacity = parseFloat(document.getElementById("op0").value);
      cfg[0].blend = "normal";
      cfg[0].inv=0; cfg[0].ct=1; cfg[0].br=1; cfg[0].sat=1; cfg[0].hue=0; cfg[0].blur=0;
      cfg[0].x=0; cfg[0].y=0; cfg[0].scale=1; cfg[0].rot=0; cfg[0].flipX=false; cfg[0].flipY=false;

      // overlay
      cfg[1].enabled = true;
      cfg[1].opacity = parseFloat(document.getElementById("op1").value);
      cfg[1].blend = document.getElementById("blend1").value;
      cfg[1].inv = parseFloat(document.getElementById("inv1").value);
      cfg[1].ct  = parseFloat(document.getElementById("ct1").value);
      cfg[1].br  = 1.0;
      cfg[1].sat = parseFloat(document.getElementById("sat1").value);
      cfg[1].hue = 0;
      cfg[1].blur = 0;
      cfg[1].x=0; cfg[1].y=0; cfg[1].scale=1; cfg[1].rot=0; cfg[1].flipX=false; cfg[1].flipY=false;
    }

    function clearPostLayers() {
      for (let i=2;i<=4;i++) {
        cfg[i].enabled = false;
        applyLayerCSS(i);
        // destroy to save CPU
        destroyPlayer(i);
      }
      post.preset = "none";
    }

    function ensureEchoPlayersLoaded() {
      // Echo layers duplicate the overlay video id (layer1)
      const ovId = loadedIds[1];
      if (!ovId) return;

      for (let i=2;i<=4;i++) {
        if (!cfg[i].enabled) continue;
        if (loadedIds[i] === ovId && players[i]) continue;
        destroyPlayer(i);
        mountPlayer(i, ovId);
      }
    }

    function bestEffortSyncEchoTimes() {
      // Align echoes near overlay time (not perfect, but helps)
      try {
        const t = players[1]?.getCurrentTime?.();
        if (typeof t !== "number") return;
        for (let i=2;i<=4;i++) {
          if (!players[i]?.seekTo) continue;
          const dt = (i-1) * 0.10; // “delay”
          try { players[i].seekTo(Math.max(0, t - dt), true); } catch(e) {}
        }
      } catch(e) {}
    }

    // ---------- Presets ----------
    function applyPreset(name) {
      post.preset = name;
      document.getElementById("postOn").checked = true;
      post.enabled = true;

      const A = parseFloat(document.getElementById("postAmt").value);
      const echoMul = parseFloat(document.getElementById("echoMul").value);

      // Enable echoes
      for (let i=2;i<=4;i++) cfg[i].enabled = true;

      // reset echo layers baseline
      for (let i=2;i<=4;i++) {
        cfg[i].opacity = 0.12 * A * echoMul;
        cfg[i].blend = "screen";
        cfg[i].inv = 0;
        cfg[i].ct = 1.15;
        cfg[i].br = 1.0;
        cfg[i].sat = 1.2;
        cfg[i].hue = 0;
        cfg[i].blur = 1.0;
        cfg[i].x = 0; cfg[i].y = 0;
        cfg[i].scale = 1.0;
        cfg[i].rot = 0;
        cfg[i].flipX = false;
        cfg[i].flipY = false;
      }

      if (name === "trail") {
        cfg[2].opacity = 0.20*A*echoMul; cfg[2].blur=2.0; cfg[2].x=  1.6*A*2; cfg[2].y= 0.6*A*2; cfg[2].blend="screen";
        cfg[3].opacity = 0.14*A*echoMul; cfg[3].blur=4.0; cfg[3].x= -1.8*A*2; cfg[3].y= 1.1*A*2; cfg[3].blend="screen";
        cfg[4].opacity = 0.10*A*echoMul; cfg[4].blur=6.0; cfg[4].x=  0.8*A*2; cfg[4].y=-1.6*A*2; cfg[4].blend="difference"; cfg[4].ct=1.35; cfg[4].sat=1.0;
      }

      if (name === "rgb") {
        cfg[2].opacity = 0.22*A*echoMul; cfg[2].blend="screen"; cfg[2].hue=  25; cfg[2].sat=1.8; cfg[2].blur=0.7; cfg[2].x=  2.0*A*2;
        cfg[3].opacity = 0.22*A*echoMul; cfg[3].blend="screen"; cfg[3].hue= -25; cfg[3].sat=1.8; cfg[3].blur=0.7; cfg[3].x= -2.0*A*2;
        cfg[4].opacity = 0.16*A*echoMul; cfg[4].blend="screen"; cfg[4].hue=   0; cfg[4].sat=2.4; cfg[4].blur=0.4; cfg[4].y=  1.4*A*2;
      }

      if (name === "glitchJit") {
        cfg[2].opacity = 0.18*A*echoMul; cfg[2].blend="difference"; cfg[2].ct=1.8; cfg[2].blur=0.4;
        cfg[3].opacity = 0.14*A*echoMul; cfg[3].blend="exclusion";  cfg[3].ct=1.6; cfg[3].blur=0.8;
        cfg[4].opacity = 0.10*A*echoMul; cfg[4].blend="screen";     cfg[4].sat=2.0; cfg[4].blur=1.2;
      }

      if (name === "glitchPop") {
        cfg[2].opacity = 0.22*A*echoMul; cfg[2].blend="difference"; cfg[2].ct=2.2; cfg[2].inv=0.15; cfg[2].blur=0.3;
        cfg[3].opacity = 0.16*A*echoMul; cfg[3].blend="difference"; cfg[3].ct=1.9; cfg[3].inv=0.10; cfg[3].blur=0.9;
        cfg[4].opacity = 0.10*A*echoMul; cfg[4].blend="screen";     cfg[4].ct=1.4; cfg[4].sat=2.2; cfg[4].blur=1.6;
      }

      if (name === "feedback") {
        // base settings come from UI in the animation loop; here we just set the “look”
        cfg[2].blend="screen";     cfg[2].opacity = 0.18*A*echoMul;
        cfg[3].blend="screen";     cfg[3].opacity = 0.14*A*echoMul;
        cfg[4].blend="difference"; cfg[4].opacity = 0.10*A*echoMul; cfg[4].ct=1.35;
      }

      if (name === "mirror") {
        // “kaleido-ish”: mirrored duplicates + rotation
        // We’ll use echoes as different mirror variants.
        cfg[2].blend="screen";     cfg[2].opacity = 0.20*A*echoMul; cfg[2].flipX = true;
        cfg[3].blend="screen";     cfg[3].opacity = 0.18*A*echoMul; cfg[3].flipY = true;
        cfg[4].blend="difference"; cfg[4].opacity = 0.12*A*echoMul; cfg[4].flipX = true; cfg[4].flipY = true; cfg[4].ct=1.25;
      }

      applyAllCSS();
      ensureEchoPlayersLoaded();
      setTimeout(bestEffortSyncEchoTimes, 800);
    }

    // ---------- Playback ----------
    async function tryAutoplayMuted() {
      let attempted = false;
      for (let i=0;i<5;i++) {
        if (i>=2 && !cfg[i].enabled) continue;
        try {
          if (players[i]) {
            players[i].mute();
            players[i].playVideo();
            attempted = true;
          }
        } catch(e) {}
      }
      return attempted;
    }

    function playAll() {
      for (let i=0;i<5;i++) {
        if (i>=2 && !cfg[i].enabled) continue;
        try { players[i] && players[i].mute(); } catch(e) {}
        try { players[i] && players[i].playVideo(); } catch(e) {}
      }
      document.getElementById("playOverlay").classList.remove("show");
    }

    function pauseAll() {
      for (let i=0;i<5;i++) { try { players[i] && players[i].pauseVideo(); } catch(e) {} }
    }

    // ---------- Load ----------
    function loadAll() {
      const id0 = extractVideoId(document.getElementById("url0").value);
      const id1 = extractVideoId(document.getElementById("url1").value);
      if (!id0 || !id1) {
        alert("Please provide valid YouTube URLs (or 11-char IDs).");
        return;
      }

      // destroy everything
      for (let i=0;i<5;i++) destroyPlayer(i);

      // main layers must be visible
      cfg[0].enabled = true;
      cfg[1].enabled = true;

      // mount base+overlay
      mountPlayer(0, id0);
      mountPlayer(1, id1);

      // post FX off by default (unless user enabled)
      post.enabled = document.getElementById("postOn").checked;
      if (!post.enabled) {
        clearPostLayers();
      } else {
        // if enabled and preset chosen, keep it
        if (post.preset !== "none") {
          ensureEchoPlayersLoaded();
        }
      }

      // apply CSS
      setMainFromUI();
      applyAllCSS();

      // attempt autoplay
      setTimeout(async () => {
        const attempted = await tryAutoplayMuted();
        document.getElementById("playOverlay").classList.toggle("show", !attempted);
      }, 700);
    }

    // ---------- Mute toggles ----------
    function toggleMute(which) {
      const p = players[which];
      if (!p) return;

      if (which===0) mutedBase = !mutedBase;
      if (which===1) mutedOv = !mutedOv;

      const muted = (which===0) ? mutedBase : mutedOv;
      const btn = document.getElementById(which===0 ? "muteBaseBtn" : "muteOvBtn");

      try { muted ? p.mute() : p.unMute(); } catch(e) {}
      btn.textContent = muted ? (which===0 ? "Unmute base" : "Unmute overlay") : (which===0 ? "Mute base" : "Mute overlay");
    }

    // ---------- Fullscreen ----------
    function isRealFullscreenSupported() {
      const stage = document.getElementById("stage");
      return !!(stage.requestFullscreen && document.fullscreenEnabled);
    }
    async function toggleFullscreen() {
      const stage = document.getElementById("stage");

      if (document.body.classList.contains("pseudo-fs")) {
        document.body.classList.remove("pseudo-fs");
        return;
      }

      if (isRealFullscreenSupported()) {
        try {
          if (document.fullscreenElement) await document.exitFullscreen();
          else await stage.requestFullscreen();
          return;
        } catch(e) {}
      }
      document.body.classList.add("pseudo-fs");
    }

    // ---------- Animation loop for “glitch / feedback / mirror mode” ----------
    function stepNoise(time, freq) {
      const k = Math.max(0.001, 1 / Math.max(0.01, freq));
      const bucket = Math.floor(time / k);
      const x = Math.sin(bucket * 999.123) * 10000;
      return (x - Math.floor(x)) * 2 - 1;
    }

    function raf(t) {
      const time = t / 1000;

      // Always update main from UI
      setMainFromUI();

      // Post enable
      post.enabled = document.getElementById("postOn").checked;

      // If disabled, hide post layers
      if (!post.enabled) {
        for (let i=2;i<=4;i++) cfg[i].enabled = false;
        applyAllCSS();
        requestAnimationFrame(raf);
        return;
      }

      // If enabled but no preset, keep post layers off
      if (post.preset === "none") {
        for (let i=2;i<=4;i++) cfg[i].enabled = false;
        applyAllCSS();
        requestAnimationFrame(raf);
        return;
      }

      // Ensure post layers are on
      for (let i=2;i<=4;i++) cfg[i].enabled = true;

      const A = parseFloat(document.getElementById("postAmt").value);
      const echoMul = parseFloat(document.getElementById("echoMul").value);
      const jitAmt = parseFloat(document.getElementById("jitAmt").value) * A;
      const jitSpd = parseFloat(document.getElementById("jitSpd").value);

      // Apply preset-specific motion behavior
      if (post.preset === "glitchJit" || post.preset === "glitchPop") {
        const n1 = stepNoise(time, jitSpd) * jitAmt;
        const n2 = stepNoise(time + 12.34, jitSpd) * jitAmt;
        cfg[2].x = n1 * 6;  cfg[2].y = n2 * 4;
        cfg[3].x = -n2 * 5; cfg[3].y = n1 * 6;
        cfg[4].x = (n1+n2) * 3; cfg[4].y = (n1-n2) * 2;

        if (post.preset === "glitchPop") {
          const pop = (Math.abs(stepNoise(time, jitSpd*0.25)) > 0.85) ? 1 : 0;
          cfg[2].ct = 1.8 + pop * 0.9;
          cfg[3].ct = 1.6 + pop * 0.7;
          cfg[4].ct = 1.3 + pop * 0.5;
          cfg[2].opacity = (0.22*A*echoMul) * (1 + pop*0.8);
          cfg[3].opacity = (0.16*A*echoMul) * (1 + pop*0.6);
          cfg[4].opacity = (0.10*A*echoMul) * (1 + pop*0.4);
        }
      }

      if (post.preset === "trail" || post.preset === "rgb") {
        // gentle “swim” for vibe
        cfg[2].x += Math.sin(time*1.2) * 0.02;
        cfg[3].y += Math.cos(time*1.1) * 0.02;
        cfg[4].x += Math.sin(time*0.9+2) * 0.02;
      }

      if (post.preset === "feedback") {
        const zoomBase = parseFloat(document.getElementById("fbZoomBase").value);
        const zoomStep = parseFloat(document.getElementById("fbZoomStep").value);
        const rotSpd = parseFloat(document.getElementById("fbRotSpd").value);
        const driftAmt = parseFloat(document.getElementById("fbDriftAmt").value) * A;
        const driftSpd = parseFloat(document.getElementById("fbDriftSpd").value);
        const blur = parseFloat(document.getElementById("fbBlur").value);

        // layered zoom
        cfg[2].scale = zoomBase + zoomStep*1;
        cfg[3].scale = zoomBase + zoomStep*2;
        cfg[4].scale = zoomBase + zoomStep*3;

        // rotation drift
        cfg[2].rot = (time * rotSpd) * 0.7 * A;
        cfg[3].rot = (time * rotSpd) * 1.0 * A;
        cfg[4].rot = (time * rotSpd) * 1.3 * A;

        // drift offsets
        cfg[2].x = Math.sin(time*driftSpd) * driftAmt;
        cfg[2].y = Math.cos(time*driftSpd*1.1) * driftAmt;

        cfg[3].x = Math.sin(time*driftSpd*1.3 + 1.2) * driftAmt * 0.9;
        cfg[3].y = Math.cos(time*driftSpd*1.0 + 0.4) * driftAmt * 0.9;

        cfg[4].x = Math.sin(time*driftSpd*0.8 + 2.1) * driftAmt * 0.8;
        cfg[4].y = Math.cos(time*driftSpd*0.9 + 1.7) * driftAmt * 0.8;

        // blur for “feedback smear”
        cfg[2].blur = blur * 0.6;
        cfg[3].blur = blur * 1.0;
        cfg[4].blur = blur * 1.4;
      }

      if (post.preset === "mirror") {
        const mode = document.getElementById("mirMode").value;
        const rot = parseFloat(document.getElementById("mirRot").value);

        // Reset flips first (preset set some, but let UI override “quad”)
        cfg[2].flipX = false; cfg[2].flipY = false;
        cfg[3].flipX = false; cfg[3].flipY = false;
        cfg[4].flipX = false; cfg[4].flipY = false;

        // Apply mode using echo layers as mirror copies
        if (mode === "mx") {
          cfg[2].flipX = true;
        } else if (mode === "my") {
          cfg[2].flipY = true;
        } else if (mode === "mxy") {
          cfg[2].flipX = true; cfg[2].flipY = true;
        } else if (mode === "quad") {
          // Use all echoes to approximate a kaleido feel
          cfg[2].flipX = true;
          cfg[3].flipY = true;
          cfg[4].flipX = true; cfg[4].flipY = true;
          cfg[2].blend = "screen";
          cfg[3].blend = "screen";
          cfg[4].blend = "difference";
          cfg[2].opacity = 0.18*A*echoMul;
          cfg[3].opacity = 0.18*A*echoMul;
          cfg[4].opacity = 0.12*A*echoMul;
          // small offsets create “segment” feel
          cfg[2].x =  1.4*A; cfg[2].y = 0;
          cfg[3].x = -1.4*A; cfg[3].y = 0;
          cfg[4].x =  0;     cfg[4].y = 1.2*A;
        }

        cfg[2].rot = rot;
        cfg[3].rot = -rot * 0.7;
        cfg[4].rot = rot * 0.4;
      }

      applyAllCSS();

      // Occasionally re-seek to keep echoes close
      if (Math.random() < 0.02) bestEffortSyncEchoTimes();

      requestAnimationFrame(raf);
    }

    // ---------- UI wiring ----------
    const controlsPanel = document.getElementById("controlsPanel");
    document.getElementById("controlsBtn").addEventListener("click", () => {
      controlsPanel.classList.toggle("open");
      document.getElementById("controlsBtn").textContent =
        controlsPanel.classList.contains("open") ? "Collapse controls" : "Expand controls";
    });
    document.getElementById("hidePanelBtn").addEventListener("click", () => {
      controlsPanel.classList.remove("open");
      document.getElementById("controlsBtn").textContent = "Expand controls";
    });

    document.getElementById("reloadBtn").addEventListener("click", loadAll);
    document.getElementById("playBtn").addEventListener("click", playAll);
    document.getElementById("pauseBtn").addEventListener("click", pauseAll);
    document.getElementById("tapPlayBtn").addEventListener("click", playAll);

    document.getElementById("fsBtn").addEventListener("click", toggleFullscreen);
    document.getElementById("hudPlay").addEventListener("click", playAll);
    document.getElementById("hudExit").addEventListener("click", toggleFullscreen);

    document.getElementById("muteBaseBtn").addEventListener("click", () => toggleMute(0));
    document.getElementById("muteOvBtn").addEventListener("click", () => toggleMute(1));

    // Post toggle
    document.getElementById("postOn").addEventListener("change", (e) => {
      post.enabled = e.target.checked;
      if (!post.enabled) {
        clearPostLayers();
        applyAllCSS();
      } else {
        // if enabling with a preset already selected, bring back echoes
        if (post.preset !== "none") {
          for (let i=2;i<=4;i++) cfg[i].enabled = true;
          ensureEchoPlayersLoaded();
          setTimeout(bestEffortSyncEchoTimes, 800);
        }
      }
    });

    // Preset buttons
    document.getElementById("presetOff").addEventListener("click", () => {
      document.getElementById("postOn").checked = false;
      post.enabled = false;
      clearPostLayers();
      applyAllCSS();
    });
    document.getElementById("pTrail").addEventListener("click", () => applyPreset("trail"));
    document.getElementById("pRGB").addEventListener("click", () => applyPreset("rgb"));
    document.getElementById("pGlitchJit").addEventListener("click", () => applyPreset("glitchJit"));
    document.getElementById("pGlitchPop").addEventListener("click", () => applyPreset("glitchPop"));
    document.getElementById("pFeedback").addEventListener("click", () => applyPreset("feedback"));
    document.getElementById("pMirror").addEventListener("click", () => applyPreset("mirror"));

    // ---------- Init defaults ----------
    document.getElementById("url0").value = DEFAULT0;
    document.getElementById("url1").value = DEFAULT1;

    const blendSel = document.getElementById("blend1");
    blendSel.innerHTML = blendModes.map(m => `<option value="${m}">${m}</option>`).join("");
    blendSel.value = "difference";

    // Post FX OFF by default
    document.getElementById("postOn").checked = false;

    // ---------- YouTube API ready ----------
    function onYouTubeIframeAPIReady() {
      // Make base/overlay visible immediately
      cfg[0].enabled = true;
      cfg[1].enabled = true;
      applyAllCSS();

      // Load and start animation loop
      loadAll();
      requestAnimationFrame(raf);

      // Keep echoes loaded if needed
      setInterval(() => {
        if (document.getElementById("postOn").checked && post.preset !== "none") {
          ensureEchoPlayersLoaded();
        }
      }, 2000);
    }
    window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;
  </script>
</body>
</html>
