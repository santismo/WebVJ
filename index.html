<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>YouTube Overlay VJ (Post FX via Echo Layers)</title>
  <style>
    :root{
      --bg:#07080c;
      --panel:#0f1118;
      --panel2:#0b0d13;
      --text:#eef1f7;
      --muted:#a9b0bf;
      --border:rgba(255,255,255,.10);
      --accent:#7aa2ff;
      --maxw:1100px;
      --radius:14px;
    }
    html,body{background:var(--bg); color:var(--text); margin:0; font-family:system-ui,-apple-system,sans-serif;}
    .wrap{max-width:var(--maxw); margin:18px auto; padding:0 14px; display:grid; gap:12px;}
    h1{font-size:18px; margin:0;}
    .topbar{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;}
    .btnrow{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    button{
      background:var(--panel);
      color:var(--text);
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      font-size:15px;
    }
    button.primary{
      border-color:rgba(122,162,255,.55);
      box-shadow:0 0 0 2px rgba(122,162,255,.10) inset;
    }
    button.ghost{background:transparent}
    .hint{font-size:12px; color:var(--muted);}

    .stage{
      position:relative;
      width:min(96vw,var(--maxw));
      aspect-ratio:16/9;
      border-radius:var(--radius);
      overflow:hidden;
      background:#000;
      border:1px solid var(--border);
    }
    .stage:fullscreen{
      width:100vw; height:100vh; aspect-ratio:auto;
      border-radius:0; border:none;
    }

    .layer{
      position:absolute; inset:0;
      transform-origin:50% 50%;
      pointer-events:none;
      will-change: transform, filter, opacity;
      display:none;
    }
    .layer.base{pointer-events:auto;}
    .layer iframe{width:100%; height:100%; border:0; display:block;}

    .playOverlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      background:linear-gradient(to bottom, rgba(0,0,0,.20), rgba(0,0,0,.65));
      backdrop-filter: blur(2px);
      opacity:0; pointer-events:none;
      transition:opacity .2s ease;
      z-index:30;
    }
    .playOverlay.show{opacity:1; pointer-events:auto;}
    .playOverlay button{
      font-size:16px;
      padding:12px 16px;
      border-radius:999px;
      background:rgba(15,17,24,.75);
      border:1px solid rgba(122,162,255,.6);
    }

    /* Pseudo fullscreen fallback (iOS) */
    body.pseudo-fs{ overflow:hidden; }
    body.pseudo-fs .wrap{ max-width:none; margin:0; padding:0; }
    body.pseudo-fs .topbar, body.pseudo-fs #controlsPanel{ display:none; }
    body.pseudo-fs .stage{
      position:fixed; inset:0; width:100vw; height:100vh;
      border-radius:0; border:none; aspect-ratio:auto;
      z-index:9999;
    }
    body.pseudo-fs .fsHud{ display:flex; }

    .fsHud{
      position:absolute; top:10px; right:10px; left:10px;
      display:none; justify-content:space-between; gap:10px;
      z-index:40; pointer-events:none;
    }
    .fsHud .hudBtn{
      pointer-events:auto;
      background:rgba(15,17,24,.65);
      border:1px solid rgba(255,255,255,.18);
      border-radius:999px;
      padding:9px 12px;
      font-size:14px;
      backdrop-filter: blur(6px);
    }

    .panel{
      background:var(--panel2);
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
    }
    .panelHead{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px; gap:10px;
      border-bottom:1px solid var(--border);
    }
    .panelBody{padding:12px; display:none;}
    .panel.open .panelBody{display:block;}
    .mini{display:flex; gap:8px; flex-wrap:wrap; align-items:center; color:var(--muted); font-size:12px;}
    .pill{
      border:1px solid var(--border);
      padding:3px 8px;
      border-radius:999px;
      background:rgba(255,255,255,.03);
    }

    .card{
      border:1px solid var(--border);
      border-radius:var(--radius);
      background:rgba(255,255,255,.02);
      overflow:hidden;
      margin-bottom:12px;
    }
    .cardHead{
      padding:10px 12px;
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
      border-bottom:1px solid var(--border);
    }
    .cardTitle{font-weight:700; font-size:14px;}
    .row{
      display:grid; gap:10px;
      grid-template-columns:1fr 1fr;
      padding:12px;
    }
    @media (max-width:820px){ .row{grid-template-columns:1fr;} }
    label{display:grid; gap:6px; font-size:13px; color:var(--muted);}
    input[type="text"], select{
      width:100%;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.30);
      color:var(--text);
      font-size:15px;
      outline:none;
    }
    input[type="range"]{width:100%;}
    .toggle{display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px; user-select:none;}
    .toggle input{transform:scale(1.05)}
    .btnGroup{display:flex; gap:10px; flex-wrap:wrap; padding:12px;}
    .btnGroup button{padding:9px 11px; font-size:14px;}
    .small{font-size:12px; color:var(--muted);}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>YouTube Overlay VJ</h1>
        <div class="hint">
          Defaults: 2 videos • overlay blend=<b>difference</b> • invert=<b>max</b> • Post FX presets (off by default) use echo layers
        </div>
      </div>
      <div class="btnrow">
        <button id="reloadBtn" class="ghost">Reload</button>
        <button id="playBtn" class="primary">Play</button>
        <button id="pauseBtn">Pause</button>
        <button id="fsBtn">Full screen</button>
        <button id="controlsBtn">Expand controls</button>
      </div>
    </div>

    <div class="stage" id="stage">
      <div class="fsHud" id="fsHud">
        <button class="hudBtn" id="hudPlay">Play</button>
        <button class="hudBtn" id="hudExit">Exit</button>
      </div>

      <!-- 0 = base, 1 = main overlay, 2-4 = post FX echo layers -->
      <div id="layer0" class="layer base"></div>
      <div id="layer1" class="layer"></div>
      <div id="layer2" class="layer"></div>
      <div id="layer3" class="layer"></div>
      <div id="layer4" class="layer"></div>

      <div class="playOverlay" id="playOverlay">
        <button id="tapPlayBtn">Tap to Play</button>
      </div>
    </div>

    <div class="panel" id="controlsPanel">
      <div class="panelHead">
        <div class="mini">
          <span class="pill">2 main layers</span>
          <span class="pill">+3 post FX echo layers</span>
          <span class="pill">works on iOS</span>
        </div>
        <div class="btnrow">
          <button id="hidePanelBtn" class="ghost">Hide</button>
        </div>
      </div>

      <div class="panelBody">
        <!-- SOURCES -->
        <div class="card">
          <div class="cardHead">
            <div class="cardTitle">Sources</div>
          </div>
          <div class="row">
            <label>Base URL (Layer 1)
              <input id="url0" type="text">
            </label>
            <label>Overlay URL (Layer 2)
              <input id="url1" type="text">
            </label>
          </div>
          <div class="row">
            <label>Base opacity
              <input id="op0" type="range" min="0" max="1" step="0.01" value="1">
            </label>
            <label>Overlay opacity
              <input id="op1" type="range" min="0" max="1" step="0.01" value="0.85">
            </label>
          </div>
          <div class="row">
            <label>Overlay blend mode
              <select id="blend1"></select>
            </label>
            <label>Overlay invert (default max)
              <input id="inv1" type="range" min="0" max="1" step="0.01" value="1">
            </label>
          </div>
          <div class="row">
            <label>Overlay contrast
              <input id="ct1" type="range" min="0.5" max="3.0" step="0.01" value="1.4">
            </label>
            <label>Overlay saturation
              <input id="sat1" type="range" min="0" max="3.0" step="0.01" value="0.9">
            </label>
          </div>

          <div class="btnGroup">
            <button id="muteBaseBtn">Unmute base</button>
            <button id="muteOvBtn">Unmute overlay</button>
          </div>
          <div class="small" style="padding:0 12px 12px;">
            Autoplay is attempted muted; unmute usually requires a tap. Post FX layers are always muted.
          </div>
        </div>

        <!-- POST FX -->
        <div class="card">
          <div class="cardHead">
            <div class="cardTitle">Post FX (Echo Layers)</div>
            <label class="toggle">
              <input id="postOn" type="checkbox">
              Enable Post FX
            </label>
          </div>

          <div class="row">
            <label>Intensity (master)
              <input id="postAmt" type="range" min="0" max="1" step="0.01" value="0.65">
            </label>
            <label>Glitch jitter amount
              <input id="jitAmt" type="range" min="0" max="1" step="0.01" value="0.35">
            </label>
          </div>
          <div class="row">
            <label>Glitch jitter speed
              <input id="jitSpd" type="range" min="0" max="40" step="0.5" value="12">
            </label>
            <label>Feedback zoom speed
              <input id="fbSpd" type="range" min="0" max="6" step="0.05" value="1.0">
            </label>
          </div>

          <div class="btnGroup">
            <button id="presetOff" class="ghost">Clear preset</button>
            <button id="pTrail">Trail Echo</button>
            <button id="pRGB">RGB Shift</button>
            <button id="pGlitchA">Glitch: Jitter</button>
            <button id="pGlitchB">Glitch: Slice</button>
            <button id="pFeedback">Feedback Tunnel</button>
          </div>
          <div class="small" style="padding:0 12px 12px;">
            Presets configure Layers 3–5 as duplicates of your overlay and blend them creatively.
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    // ---------- Defaults ----------
    const DEFAULT0 = "https://m.youtube.com/watch?v=3pxrECZYEAA&pp=ygUOdmlzdWFscyB0cmlwcHk%3D";
    const DEFAULT1 = "https://m.youtube.com/watch?v=dS-MaUk6YBI";

    const blendModes = [
      "normal","multiply","screen","overlay","darken","lighten","color-dodge","color-burn",
      "hard-light","soft-light","difference","exclusion","hue","saturation","color","luminosity"
    ];

    // ---------- Player handles ----------
    const players = new Array(5).fill(null);
    const layerVideoIds = new Array(5).fill(null); // remember which id is loaded in each layer
    let mutedBase = true;
    let mutedOv = true;

    // ---------- Post FX state ----------
    const post = {
      enabled: false,
      preset: "none",
      amt: 0.65,
      jitAmt: 0.35,
      jitSpd: 12,
      fbSpd: 1.0
    };

    // layer config (CSS-only)
    const cfg = Array.from({length: 5}, (_, i) => ({
      enabled: false,
      opacity: 1,
      blend: "normal",
      inv: 0,
      ct: 1,
      br: 1,
      sat: 1,
      hue: 0,
      blur: 0,
      // transforms (percent translate)
      x: 0, y: 0,
      scale: 1,
      rot: 0
    }));

    // ---------- Helpers ----------
    function extractVideoId(url) {
      if (!url) return null;
      const raw = url.trim();
      if (/^[a-zA-Z0-9_-]{11}$/.test(raw)) return raw;
      try {
        const u = new URL(raw);
        if (u.hostname.includes("youtu.be")) return u.pathname.replace("/", "") || null;
        const v = u.searchParams.get("v");
        if (v) return v;
        const parts = u.pathname.split("/").filter(Boolean);
        const embedIdx = parts.indexOf("embed");
        if (embedIdx >= 0 && parts[embedIdx + 1]) return parts[embedIdx + 1];
      } catch (e) {}
      return null;
    }

    function mountPlayer(layerIndex, videoId) {
      const layer = document.getElementById(`layer${layerIndex}`);
      layer.innerHTML = `<div id="player${layerIndex}"></div>`;
      return new YT.Player(`player${layerIndex}`, {
        videoId,
        playerVars: { playsinline: 1, rel: 0 },
        events: {
          onReady: (e) => {
            // keep muted for autoplay compatibility
            try { e.target.mute(); } catch(e) {}
          }
        }
      });
    }

    function destroyPlayer(i) {
      if (players[i] && players[i].destroy) {
        try { players[i].destroy(); } catch(e) {}
      }
      players[i] = null;
      layerVideoIds[i] = null;
    }

    function applyLayerCSS(i) {
      const el = document.getElementById(`layer${i}`);
      const c = cfg[i];

      el.style.display = c.enabled ? "block" : "none";
      el.style.opacity = c.opacity;
      el.style.mixBlendMode = c.blend;
      el.style.transform =
        `translate(${c.x}%, ${c.y}%) scale(${c.scale}) rotate(${c.rot}deg)`;

      el.style.filter =
        `invert(${c.inv}) contrast(${c.ct}) brightness(${c.br}) saturate(${c.sat}) hue-rotate(${c.hue}deg) blur(${c.blur}px)`;
    }

    function applyAllCSS() {
      for (let i = 0; i < 5; i++) applyLayerCSS(i);
      // only layer0 interactive
      for (let i = 0; i < 5; i++) {
        document.getElementById(`layer${i}`).classList.toggle("base", i === 0);
      }
    }

    function setMainDefaultsFromUI() {
      // Layer0 base
      cfg[0].enabled = true;
      cfg[0].opacity = parseFloat(document.getElementById("op0").value);
      cfg[0].blend = "normal";
      cfg[0].inv = 0; cfg[0].ct = 1; cfg[0].br = 1; cfg[0].sat = 1; cfg[0].hue = 0; cfg[0].blur = 0;
      cfg[0].x = 0; cfg[0].y = 0; cfg[0].scale = 1; cfg[0].rot = 0;

      // Layer1 overlay
      cfg[1].enabled = true;
      cfg[1].opacity = parseFloat(document.getElementById("op1").value);
      cfg[1].blend = document.getElementById("blend1").value;
      cfg[1].inv = parseFloat(document.getElementById("inv1").value);
      cfg[1].ct  = parseFloat(document.getElementById("ct1").value);
      cfg[1].br  = 1.0;
      cfg[1].sat = parseFloat(document.getElementById("sat1").value);
      cfg[1].hue = 0;
      cfg[1].blur = 0;
      cfg[1].x = 0; cfg[1].y = 0; cfg[1].scale = 1; cfg[1].rot = 0;
    }

    function clearPostLayers() {
      // disable 2-4 + destroy players to save CPU
      for (let i = 2; i <= 4; i++) {
        cfg[i].enabled = false;
        applyLayerCSS(i);
        destroyPlayer(i);
      }
      post.preset = "none";
    }

    function syncEchoLayersToOverlay() {
      // Load echo layers with same overlay videoId as layer1
      const ovId = layerVideoIds[1];
      if (!ovId) return;

      for (let i = 2; i <= 4; i++) {
        if (!cfg[i].enabled) continue;
        if (layerVideoIds[i] === ovId && players[i]) continue;

        // rebuild player in that layer
        destroyPlayer(i);
        cfg[i].enabled = true;
        applyLayerCSS(i);
        players[i] = mountPlayer(i, ovId);
        layerVideoIds[i] = ovId;
      }
    }

    function trySeekEchoesNearOverlay() {
      // Best-effort: align echo layers to overlay current time (may be blocked on some devices)
      try {
        const t = players[1]?.getCurrentTime?.();
        if (typeof t !== "number") return;
        for (let i = 2; i <= 4; i++) {
          if (!players[i] || !players[i].seekTo) continue;
          // slight offsets can create "delay" vibe
          const dt = (i - 1) * 0.08; // 80ms-ish
          try { players[i].seekTo(Math.max(0, t - dt), true); } catch(e) {}
        }
      } catch(e) {}
    }

    // ---------- Presets (configure cfg[2..4]) ----------
    function applyPreset(name) {
      post.preset = name;

      // Make sure post is enabled
      post.enabled = document.getElementById("postOn").checked = true;

      // base from UI
      setMainDefaultsFromUI();

      // master
      post.amt = parseFloat(document.getElementById("postAmt").value);
      post.jitAmt = parseFloat(document.getElementById("jitAmt").value);
      post.jitSpd = parseFloat(document.getElementById("jitSpd").value);
      post.fbSpd = parseFloat(document.getElementById("fbSpd").value);

      // Start from clean
      for (let i = 2; i <= 4; i++) {
        cfg[i] = {
          enabled: true,
          opacity: 0,
          blend: "screen",
          inv: 0, ct: 1.0, br: 1.0, sat: 1.0, hue: 0, blur: 0,
          x: 0, y: 0, scale: 1, rot: 0
        };
      }

      // Scale effects by master amount
      const A = post.amt;

      if (name === "trail") {
        // “echo smear” stack
        cfg[2].opacity = 0.18 * A; cfg[2].blend = "screen";    cfg[2].blur = 2.0; cfg[2].x =  1.0*A*2; cfg[2].y =  0.5*A*2; cfg[2].ct = 1.2; cfg[2].sat = 1.1;
        cfg[3].opacity = 0.12 * A; cfg[3].blend = "screen";    cfg[3].blur = 4.0; cfg[3].x = -1.0*A*2; cfg[3].y =  1.0*A*2; cfg[3].ct = 1.3; cfg[3].sat = 1.0;
        cfg[4].opacity = 0.08 * A; cfg[4].blend = "difference";cfg[4].blur = 6.0; cfg[4].x =  0.5*A*2; cfg[4].y = -1.0*A*2; cfg[4].ct = 1.4; cfg[4].sat = 0.9;
      }

      if (name === "rgb") {
        // “chromatic-ish” — three echoes, different hue/offset
        cfg[2].opacity = 0.22 * A; cfg[2].blend = "screen"; cfg[2].hue =  25; cfg[2].sat = 1.6; cfg[2].ct = 1.25; cfg[2].blur = 0.6; cfg[2].x =  1.2*A*2; cfg[2].y =  0.0;
        cfg[3].opacity = 0.22 * A; cfg[3].blend = "screen"; cfg[3].hue = -25; cfg[3].sat = 1.6; cfg[3].ct = 1.25; cfg[3].blur = 0.6; cfg[3].x = -1.2*A*2; cfg[3].y =  0.0;
        cfg[4].opacity = 0.16 * A; cfg[4].blend = "screen"; cfg[4].hue =  0;  cfg[4].sat = 2.2; cfg[4].ct = 1.1;  cfg[4].blur = 0.3; cfg[4].x =  0.0;     cfg[4].y =  0.9*A*2;
      }

      if (name === "glitchA") {
        // Jitter + harsh difference edges
        cfg[2].opacity = 0.20 * A; cfg[2].blend="difference"; cfg[2].ct=1.8; cfg[2].sat=1.0; cfg[2].blur=0.2;
        cfg[3].opacity = 0.14 * A; cfg[3].blend="exclusion";  cfg[3].ct=1.6; cfg[3].sat=1.2; cfg[3].blur=0.6;
        cfg[4].opacity = 0.10 * A; cfg[4].blend="screen";     cfg[4].ct=1.3; cfg[4].sat=1.6; cfg[4].blur=1.2;
      }

      if (name === "glitchB") {
        // “slice-ish”: offsets are driven by the animation loop in chunked steps
        cfg[2].opacity = 0.18 * A; cfg[2].blend="difference"; cfg[2].ct=1.7; cfg[2].blur=0.4;
        cfg[3].opacity = 0.16 * A; cfg[3].blend="difference"; cfg[3].ct=1.5; cfg[3].blur=0.8;
        cfg[4].opacity = 0.12 * A; cfg[4].blend="screen";     cfg[4].ct=1.2; cfg[4].blur=1.0; cfg[4].sat=1.8;
      }

      if (name === "feedback") {
        // Zoom tunnel illusion
        cfg[2].opacity = 0.18 * A; cfg[2].blend="screen";     cfg[2].blur=0.8; cfg[2].scale = 1.02;
        cfg[3].opacity = 0.14 * A; cfg[3].blend="screen";     cfg[3].blur=1.6; cfg[3].scale = 1.04;
        cfg[4].opacity = 0.10 * A; cfg[4].blend="difference"; cfg[4].blur=2.4; cfg[4].scale = 1.06;
      }

      // Apply + ensure echoes loaded
      applyAllCSS();
      syncEchoLayersToOverlay();
      // best-effort sync time
      setTimeout(trySeekEchoesNearOverlay, 800);
    }

    // ---------- Playback ----------
    async function tryAutoplayMuted() {
      let attempted = false;
      for (let i = 0; i <= 1; i++) {
        try {
          if (players[i]) { players[i].mute(); players[i].playVideo(); attempted = true; }
        } catch(e) {}
      }
      // Post layers, if enabled, also play muted
      for (let i = 2; i <= 4; i++) {
        if (!cfg[i].enabled) continue;
        try {
          if (players[i]) { players[i].mute(); players[i].playVideo(); attempted = true; }
        } catch(e) {}
      }
      return attempted;
    }

    function playAll() {
      for (let i = 0; i <= 1; i++) {
        try { players[i] && players[i].mute(); } catch(e) {}
        try { players[i] && players[i].playVideo(); } catch(e) {}
      }
      for (let i = 2; i <= 4; i++) {
        if (!cfg[i].enabled) continue;
        try { players[i] && players[i].mute(); } catch(e) {}
        try { players[i] && players[i].playVideo(); } catch(e) {}
      }
      document.getElementById("playOverlay").classList.remove("show");
    }

    function pauseAll() {
      for (let i = 0; i < 5; i++) {
        try { players[i] && players[i].pauseVideo(); } catch(e) {}
      }
    }

    // ---------- Load / Reload ----------
    function loadAll() {
      const id0 = extractVideoId(document.getElementById("url0").value);
      const id1 = extractVideoId(document.getElementById("url1").value);
      if (!id0 || !id1) {
        alert("Please provide valid YouTube URLs (or 11-char IDs).");
        return;
      }

      // destroy all players
      for (let i = 0; i < 5; i++) destroyPlayer(i);

      // Main layer CSS
      setMainDefaultsFromUI();

      // Show main layers
      cfg[0].enabled = true;
      cfg[1].enabled = true;

      // Create players for main layers
      players[0] = mountPlayer(0, id0); layerVideoIds[0] = id0;
      players[1] = mountPlayer(1, id1); layerVideoIds[1] = id1;

      // Post FX off by default unless user enabled
      if (!post.enabled) {
        clearPostLayers();
      } else {
        // if enabled and preset active, reapply
        if (post.preset !== "none") {
          applyPreset(post.preset);
        } else {
          // enabled but no preset: leave post layers off
          clearPostLayers();
        }
      }

      applyAllCSS();

      setTimeout(async () => {
        const attempted = await tryAutoplayMuted();
        // Autoplay can still fail; show tap overlay if it looks like nothing started
        document.getElementById("playOverlay").classList.toggle("show", !attempted);
      }, 650);
    }

    // ---------- Mute toggles ----------
    function toggleMute(which) {
      const p = players[which];
      if (!p) return;

      if (which === 0) mutedBase = !mutedBase;
      if (which === 1) mutedOv = !mutedOv;

      const muted = which === 0 ? mutedBase : mutedOv;
      const btn = document.getElementById(which === 0 ? "muteBaseBtn" : "muteOvBtn");
      try { muted ? p.mute() : p.unMute(); } catch(e) {}
      btn.textContent = muted ? (which === 0 ? "Unmute base" : "Unmute overlay") : (which === 0 ? "Mute base" : "Mute overlay");
    }

    // ---------- Fullscreen (real + pseudo fallback) ----------
    function isRealFullscreenSupported() {
      const stage = document.getElementById("stage");
      return !!(stage.requestFullscreen && document.fullscreenEnabled);
    }
    async function toggleFullscreen() {
      const stage = document.getElementById("stage");

      if (document.body.classList.contains("pseudo-fs")) {
        document.body.classList.remove("pseudo-fs");
        return;
      }

      if (isRealFullscreenSupported()) {
        try {
          if (document.fullscreenElement) await document.exitFullscreen();
          else await stage.requestFullscreen();
          return;
        } catch(e) { /* fallthrough */ }
      }
      document.body.classList.add("pseudo-fs");
    }

    // ---------- “Glitch / feedback” animation loop ----------
    let lastT = performance.now();
    function randSigned() { return (Math.random() * 2 - 1); }
    function stepNoise(time, freq) {
      // chunky jitter: hold random value for a small window
      const k = Math.max(0.001, 1 / Math.max(0.01, freq));
      const bucket = Math.floor(time / k);
      // deterministic-ish per bucket
      const x = Math.sin(bucket * 999.123) * 10000;
      return (x - Math.floor(x)) * 2 - 1;
    }

    function raf(t) {
      const time = t / 1000;
      const dt = (t - lastT) / 1000;
      lastT = t;

      // Keep UI-driven main CSS always applied
      // (cheap; ensures sliders reflect immediately)
      setMainDefaultsFromUI();

      // Update post controls
      post.enabled = document.getElementById("postOn").checked;
      post.amt = parseFloat(document.getElementById("postAmt").value);
      post.jitAmt = parseFloat(document.getElementById("jitAmt").value);
      post.jitSpd = parseFloat(document.getElementById("jitSpd").value);
      post.fbSpd = parseFloat(document.getElementById("fbSpd").value);

      // If post disabled, ensure post layers are hidden (but don't constantly destroy players)
      if (!post.enabled) {
        for (let i = 2; i <= 4; i++) cfg[i].enabled = false;
      } else {
        // Ensure echo layers exist if a preset is active
        if (post.preset !== "none") {
          for (let i = 2; i <= 4; i++) cfg[i].enabled = true;
        }
      }

      // Animate certain presets
      if (post.enabled && post.preset !== "none") {
        const A = post.amt;

        if (post.preset === "feedback") {
          // slowly breathing zoom tunnel
          const z = 1 + Math.sin(time * Math.PI * 2 * post.fbSpd) * (0.02 * A);
          cfg[2].scale = 1.02 * z;
          cfg[3].scale = 1.04 * z;
          cfg[4].scale = 1.06 * z;
          // gentle rotation drift
          cfg[2].rot = Math.sin(time*0.7) * 0.6 * A;
          cfg[3].rot = Math.sin(time*0.9) * 0.9 * A;
          cfg[4].rot = Math.sin(time*1.1) * 1.2 * A;
        }

        if (post.preset === "glitchA") {
          // fast jitter: random offsets each frame scaled by sliders
          const j = post.jitAmt * A;
          const spd = post.jitSpd;
          const n1 = stepNoise(time, spd) * j;
          const n2 = stepNoise(time + 12.34, spd) * j;
          cfg[2].x = n1 * 3; cfg[2].y = n2 * 2;
          cfg[3].x = -n2 * 2; cfg[3].y = n1 * 3;
          cfg[4].x = (n1+n2) * 1.5; cfg[4].y = (n1-n2) * 1.2;
        }

        if (post.preset === "glitchB") {
          // chunky “slice-ish” jitter: stepwise offsets + occasional jump
          const j = post.jitAmt * A;
          const spd = post.jitSpd;
          const n = stepNoise(time, spd);
          const m = stepNoise(time + 5.67, spd * 0.6);
          const jump = (Math.abs(stepNoise(time, spd*0.25)) > 0.82) ? 1 : 0;

          cfg[2].x = (n * 4) * j; cfg[2].y = (m * 1.5) * j;
          cfg[3].x = (-n * 6) * j; cfg[3].y = (m * 2.0) * j;
          cfg[4].x = (jump ? (randSigned()*10*j) : (n * 2.5) * j);
          cfg[4].y = (jump ? (randSigned()*6*j) : (-m * 2.2) * j);

          // brief brightness “flash” impression
          cfg[2].ct = 1.6 + jump * 0.8;
          cfg[3].ct = 1.4 + jump * 0.7;
          cfg[4].ct = 1.2 + jump * 0.5;
        }

        if (post.preset === "trail") {
          // gentle drifting echoes for “trail” feel
          cfg[2].x = Math.sin(time*0.9) * 1.8 * A;
          cfg[2].y = Math.cos(time*1.1) * 1.2 * A;
          cfg[3].x = Math.sin(time*0.7 + 1.2) * -2.2 * A;
          cfg[3].y = Math.cos(time*0.8 + 0.6) * 1.7 * A;
          cfg[4].x = Math.sin(time*0.5 + 2.4) * 1.3 * A;
          cfg[4].y = Math.cos(time*0.6 + 1.9) * -1.9 * A;
        }

        if (post.preset === "rgb") {
          // subtle oscillation in offsets to make chroma “swim”
          cfg[2].x =  2.0*A + Math.sin(time*1.8)*0.8*A; cfg[2].y = 0;
          cfg[3].x = -2.0*A + Math.sin(time*1.6+1)*0.8*A; cfg[3].y = 0;
          cfg[4].x = 0; cfg[4].y =  1.4*A + Math.sin(time*1.2+2)*0.6*A;
        }

        // Ensure echo layers stay aligned-ish
        if (Math.random() < 0.02) { // occasionally re-seek
          trySeekEchoesNearOverlay();
        }
      }

      applyAllCSS();
      requestAnimationFrame(raf);
    }

    // ---------- UI wiring ----------
    const controlsPanel = document.getElementById("controlsPanel");
    document.getElementById("controlsBtn").addEventListener("click", () => {
      controlsPanel.classList.toggle("open");
      document.getElementById("controlsBtn").textContent =
        controlsPanel.classList.contains("open") ? "Collapse controls" : "Expand controls";
    });
    document.getElementById("hidePanelBtn").addEventListener("click", () => {
      controlsPanel.classList.remove("open");
      document.getElementById("controlsBtn").textContent = "Expand controls";
    });

    document.getElementById("reloadBtn").addEventListener("click", loadAll);
    document.getElementById("playBtn").addEventListener("click", playAll);
    document.getElementById("pauseBtn").addEventListener("click", pauseAll);
    document.getElementById("tapPlayBtn").addEventListener("click", playAll);
    document.getElementById("fsBtn").addEventListener("click", toggleFullscreen);
    document.getElementById("hudPlay").addEventListener("click", playAll);
    document.getElementById("hudExit").addEventListener("click", toggleFullscreen);

    document.getElementById("muteBaseBtn").addEventListener("click", () => toggleMute(0));
    document.getElementById("muteOvBtn").addEventListener("click", () => toggleMute(1));

    // Sliders update immediately (CSS), but reload is needed to change video URLs
    ["op0","op1","blend1","inv1","ct1","sat1"].forEach(id => {
      document.getElementById(id).addEventListener("input", () => { /* RAF applies */ });
      document.getElementById(id).addEventListener("change", () => { /* RAF applies */ });
    });

    // Post toggles
    document.getElementById("postOn").addEventListener("change", (e) => {
      post.enabled = e.target.checked;
      if (!post.enabled) {
        clearPostLayers();
        applyAllCSS();
      } else {
        // enable but no preset: do nothing until user picks a preset
        applyAllCSS();
      }
    });

    // Presets
    document.getElementById("presetOff").addEventListener("click", () => {
      post.preset = "none";
      document.getElementById("postOn").checked = false;
      post.enabled = false;
      clearPostLayers();
      applyAllCSS();
    });

    document.getElementById("pTrail").addEventListener("click", () => applyPreset("trail"));
    document.getElementById("pRGB").addEventListener("click", () => applyPreset("rgb"));
    document.getElementById("pGlitchA").addEventListener("click", () => applyPreset("glitchA"));
    document.getElementById("pGlitchB").addEventListener("click", () => applyPreset("glitchB"));
    document.getElementById("pFeedback").addEventListener("click", () => applyPreset("feedback"));

    // Keep echo layers loaded if post is enabled + preset active, and overlay changes
    function ensureEchoes() {
      if (!post.enabled || post.preset === "none") return;
      syncEchoLayersToOverlay();
    }

    // ---------- Init UI defaults ----------
    document.getElementById("url0").value = DEFAULT0;
    document.getElementById("url1").value = DEFAULT1;

    const blendSel = document.getElementById("blend1");
    blendSel.innerHTML = blendModes.map(m => `<option value="${m}">${m}</option>`).join("");
    blendSel.value = "difference";

    document.getElementById("inv1").value = "1"; // invert max default

    // Post FX OFF by default
    document.getElementById("postOn").checked = false;

    // ---------- YouTube API ready ----------
    function onYouTubeIframeAPIReady() {
      // Start main layers visible immediately
      cfg[0].enabled = true;
      cfg[1].enabled = true;
      applyAllCSS();
      loadAll();
      requestAnimationFrame(raf);
      // periodically ensure echoes if enabled
      setInterval(ensureEchoes, 1500);
    }
    window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;
  </script>
</body>
</html>
